category: Ticketing
commonfields: {id: Freshdesk, version: -1}
configuration:
- defaultvalue: https://example.net
  display: Server URL (e.g. https://example.net)
  name: url
  options: []
  required: true
  type: 0
- defaultvalue: ''
  display: API Token
  name: token
  options: []
  required: false
  type: 4
- defaultvalue: 'true'
  display: Trust any certificate (unsecure)
  name: insecure
  options: []
  required: false
  type: 8
- defaultvalue: ''
  display: Use system proxy
  name: proxy
  options: []
  required: false
  type: 8
- defaultvalue: 3 days
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days)
  name: fetch_time
  options: []
  required: false
  type: 0
- defaultvalue: ''
  display: Username
  name: credentials
  options: []
  required: false
  type: 9
description: Freshdesk Integration
detaileddescription: Use these detailed instructions in order to retrieve the API
  key
display: Freshdesk
name: Freshdesk
script:
  commands:
  - arguments:
    - default: false
      defaultValue: ''
      description: Subject of the ticket. The default Value is null.
      isArray: false
      name: subject
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: Details of the issue for which you are creating a ticket.
      isArray: false
      name: description
      predefined: []
      required: true
    - default: false
      defaultValue: '1'
      description: Priority of the ticket. Each number has a corresponding value.
        1 is Low, 2 is Medium, 3 is High, 4 is Urgent.
      isArray: false
      name: priority
      predefined: ['1', '2', '3', '4']
      required: false
    - default: false
      defaultValue: '2'
      description: Status of the ticket. Each number has a corresponding value. 2
        is Open, 3 is Pending, 4 is Resolved, 5 is Closed, 6 is Waiting on Customer,
        7 is Waiting on Third Party.
      isArray: false
      name: status
      predefined: ['2', '3', '4', '5', '6', '7']
      required: false
    - default: false
      defaultValue: ''
      description: This can be an email address or a twitter handle
      isArray: false
      name: identifier
      predefined: []
      required: true
    - default: false
      defaultValue: ''
      description: ID or name of the group or agent to whom you wish to assign this
        ticket. To find potential assignees, try executing the fd-list-groups or fd-list-contacts
        commands.
      isArray: false
      name: responder
      predefined: []
      required: false
    description: Create a new Freshdesk ticket.
    execution: false
    name: fd-create-ticket
    outputs:
    - {contextPath: FD.Ticket.Priority, description: Priority of the ticket, type: Number}
    - {contextPath: FD.Ticket.DueBy, description: Timestamp that denotes when the
        ticket is due to be resolved, type: Date}
    - {contextPath: FD.Ticket.Subject, description: Subject of the ticket, type: String}
    - {contextPath: FD.Ticket.Attachments, description: Ticket attachments. The total
        size of these attachments cannot exceed 15MB., type: Unknown}
    - {contextPath: FD.Ticket.Status, description: Status of the ticket, type: Number}
    - {contextPath: FD.Ticket.RequesterId, description: User ID of the requester,
      type: Number}
    - {contextPath: FD.Ticket.Tags, description: Tags that have been associated with
        the ticket, type: Unknown}
    - {contextPath: FD.Ticket.GroupId, description: ID of the group to which the ticket
        has been assigned, type: Number}
    - {contextPath: FD.Ticket.Source, description: The channel through which the ticket
        was created, type: Number}
    - {contextPath: FD.Ticket.CreatedAt, description: Ticket creation timestamp, type: Date}
    - {contextPath: FD.Ticket.ResponderId, description: ID of the agent to whom the
        ticket has been assigned, type: Number}
    - {contextPath: FD.Ticket.FrDueBy, description: Timestamp that denotes when the
        first response is due, type: Date}
    - {contextPath: FD.Ticket.Id, description: ID number of the ticket, type: Number}
  - arguments:
    - default: false
      defaultValue: ''
      description: ID number of the ticket to fetch
      isArray: false
      name: id
      predefined: []
      required: true
    description: View a Ticket.
    execution: false
    name: fd-view-ticket
    outputs:
    - {contextPath: FD.Ticket.Priority, description: Priority of the ticket, type: Number}
    - {contextPath: FD.Ticket.DueBy, description: Timestamp that denotes when the
        ticket is due to be resolved, type: Date}
    - {contextPath: FD.Ticket.Subject, description: Subject of the ticket, type: String}
    - {contextPath: FD.Ticket.Attachments, description: Ticket attachments. The total
        size of these attachments cannot exceed 15MB., type: Unknown}
    - {contextPath: FD.Ticket.Status, description: Status of the ticket, type: Number}
    - {contextPath: FD.Ticket.RequesterId, description: User ID of the requester,
      type: Number}
    - {contextPath: FD.Ticket.Tags, description: Tags that have been associated with
        the ticket, type: Unknown}
    - {contextPath: FD.Ticket.GroupId, description: ID of the group to which the ticket
        has been assigned, type: Number}
    - {contextPath: FD.Ticket.Source, description: The channel through which the ticket
        was created, type: Number}
    - {contextPath: FD.Ticket.CreatedAt, description: Ticket creation timestamp, type: Date}
    - {contextPath: FD.Ticket.ResponderId, description: ID of the agent to whom the
        ticket has been assigned, type: Number}
    - {contextPath: FD.Ticket.FrDueBy, description: Timestamp that denotes when the
        first response is due, type: Date}
    - {contextPath: FD.Ticket.Conversation, description: Conversations associated
        with this ticket, type: Unknown}
    - {contextPath: FD.Ticket.Id, description: ID of the fetched ticket, type: Number}
  - arguments:
    - default: false
      defaultValue: ''
      description: Subject of the ticket. The default Value is null.
      isArray: false
      name: subject
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: Status of the ticket. Each number has a corresponding value. 2
        is Open, 3 is Pending, 4 is Resolved, 5 is Closed, 6 is Waiting on Customer,
        7 is Waiting on Third Party.
      isArray: false
      name: status
      predefined: ['2', Open, '3', Pending, '4', Resolved, '5', Closed, '6', Waiting
          on Customer, '7', Waiting on Third Party]
      required: false
    - default: false
      defaultValue: ''
      description: Priority of the ticket. Each number has a corresponding value.
        1 is Low, 2 is Medium, 3 is High, 4 is Urgent.
      isArray: false
      name: priority
      predefined: ['1', Low, '2', Medium, '3', High, '4', Urgent]
      required: false
    - default: false
      defaultValue: ''
      description: HTML content of the ticket.
      isArray: false
      name: description
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: ID number of the ticket to update
      isArray: false
      name: id
      predefined: []
      required: true
    - default: false
      defaultValue: ''
      description: Update which agent is assigned to respond to this ticket by entering
        either their unique agent ID, name, or email.
      isArray: false
      name: assigned_agent
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: Update the group assigned to respond to this ticket by entering
        the group's unique ID or the name of the group.
      isArray: false
      name: assigned_group
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: List of ticket fields you wish to update the values of.
      isArray: true
      name: update_fields
      predefined: [name, requester_id, email, facebook_id, phone, twitter_id, unique_external_id,
        type, attachments, custom_fields, email_config_id, product_id, source, tags,
        company_id, due_by, fr_due_by]
      required: false
    - default: false
      defaultValue: ''
      description: List of values that are assigned to the field at the same list
        index in the update_fields argument.
      isArray: true
      name: update_values
      predefined: []
      required: false
    description: Update the ticket specified by the ID
    execution: false
    name: fd-update-ticket
    outputs:
    - {contextPath: FD.Ticket.Priority, description: Priority of the ticket, type: Number}
    - {contextPath: FD.Ticket.DueBy, description: Timestamp that denotes when the
        ticket is due to be resolved, type: Date}
    - {contextPath: FD.Ticket.Subject, description: Subject of the ticket, type: String}
    - {contextPath: FD.Ticket.Attachments, description: Ticket attachments. The total
        size of these attachments cannot exceed 15MB., type: Unknown}
    - {contextPath: FD.Ticket.Status, description: Status of the ticket, type: Number}
    - {contextPath: FD.Ticket.RequesterId, description: User ID of the requester,
      type: Number}
    - {contextPath: FD.Ticket.Tags, description: Tags that have been associated with
        the ticket, type: Unknown}
    - {contextPath: FD.Ticket.GroupId, description: ID of the group to which the ticket
        has been assigned, type: Number}
    - {contextPath: FD.Ticket.Source, description: The channel through which the ticket
        was created, type: Number}
    - {contextPath: FD.Ticket.CreatedAt, description: Ticket creation timestamp, type: Date}
    - {contextPath: FD.Ticket.ResponderId, description: ID of the agent to whom the
        ticket has been assigned, type: Number}
    - {contextPath: FD.Ticket.FrDueBy, description: Timestamp that denotes when the
        first response is due, type: Date}
    - {contextPath: FD.Ticket.UpdatedAt, description: Ticket update timestamp, type: Date}
    - {contextPath: FD.Ticket.UpdatedField, description: Additional fields that were
        updated using the 'update_fields' and 'update_values' arguments., type: Unknown}
    - {contextPath: FD.Ticket.Id, description: ID of the updated ticket, type: Number}
  - arguments:
    - default: false
      defaultValue: ''
      description: mobile number to filter the contacts by
      isArray: false
      name: mobile
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: phone number to filter contacts by
      isArray: false
      name: phone
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: Company ID by which to filter the contacts
      isArray: false
      name: company_id
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: The state of contacts by which you want to filter the contacts
      isArray: false
      name: state
      predefined: [blocked, deleted, unverified, verified]
      required: false
    - default: false
      defaultValue: ''
      description: return contacts that have been updated after the timestamp given
        as this argument value
      isArray: false
      name: updated_since
      predefined: []
      required: false
    description: List all contacts matching the specified filters. If no filters are
      provided then all unblocked and undeleted contacts will be returned.
    execution: false
    name: fd-list-contacts
    outputs:
    - {contextPath: FD.Contact.Active, description: Set to true if the contact has
        been verified, type: Boolean}
    - {contextPath: FD.Contact.Address, description: Address of the contact, type: String}
    - {contextPath: FD.Contact.Avatar, description: Avatar of the contact, type: Unknown}
    - {contextPath: FD.Contact.CompanyId, description: ID of the primary company to
        which this contact belongs, type: Number}
    - {contextPath: FD.Contact.ViewAllTickets, description: Set to true if the contact
        can see all tickets that are associated with the company to which s/he belong,
      type: Boolean}
    - {contextPath: FD.Contact.CustomFields, description: Key value pair containing
        the name and value of the custom fields., type: Unknown}
    - {contextPath: FD.Contact.Deleted, description: Set to true if the contact has
        been deleted., type: Boolean}
    - {contextPath: FD.Contact.Description, description: A short description of the
        contact, type: String}
    - {contextPath: FD.Contact.Email, description: Primary email address of the contact.,
      type: String}
    - {contextPath: FD.Contact.Id, description: ID of the contact, type: Number}
    - {contextPath: FD.Contact.JobTitle, description: Job Title of the contact, type: String}
    - {contextPath: FD.Contact.Language, description: Language of the contact, type: String}
    - {contextPath: FD.Contact.Mobile, description: Mobile number of the contact,
      type: Number}
    - {contextPath: FD.Contact.Name, description: Name of the contact, type: String}
    - {contextPath: FD.Contact.OtherEmails, description: Additional emails associated
        with the contact, type: Unknown}
    - {contextPath: FD.Contact.Phone, description: Telephone number of the contact,
      type: Number}
    - {contextPath: FD.Contact.Tags, description: Tags associated with this contact,
      type: Unknown}
    - {contextPath: FD.Contact.TimeZone, description: Time zone in which the contact
        resides, type: String}
    - {contextPath: FD.Contact.TwitterId, description: Twitter handle of the contact,
      type: String}
    - {contextPath: FD.Contact.UniqueExternalId, description: External ID of the contact,
      type: String}
    - {contextPath: FD.Contact.OtherCompanies, description: Additional companies associated
        with the contact (array of hashes), type: Unknown}
    - {contextPath: FD.Contact.CreatedAt, description: Contact creation stamp, type: Date}
    - {contextPath: FD.Contact.UpdatedAt, description: Contact updated timestamp,
      type: Date}
  - arguments:
    - default: false
      defaultValue: ''
      description: ID of the contact you wish to view the details of
      isArray: false
      name: id
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: Mobile number of the contact you wish to view the details of
      isArray: false
      name: mobile
      predefined: []
      required: false
    description: View the details of the contact specified by the ID number
    execution: false
    name: fd-view-contact
    outputs:
    - {contextPath: FD.Contact.Active, description: Set to true if the contact has
        been verified, type: Boolean}
    - {contextPath: FD.Contact.Address, description: Address of the contact, type: String}
    - {contextPath: FD.Contact.Avatar, description: Avatar of the contact, type: Unknown}
    - {contextPath: FD.Contact.CompanyId, description: ID of the primary company to
        which this contact belongs, type: Number}
    - {contextPath: FD.Contact.ViewAllTickets, description: Set to true if the contact
        can see all tickets that are associated with the company to which s/he belong,
      type: Boolean}
    - {contextPath: FD.Contact.CustomFields, description: Key value pair containing
        the name and value of the custom fields., type: Unknown}
    - {contextPath: FD.Contact.Deleted, description: Set to true if the contact has
        been deleted., type: Boolean}
    - {contextPath: FD.Contact.Description, description: A short description of the
        contact, type: String}
    - {contextPath: FD.Contact.Email, description: Primary email address of the contact.,
      type: String}
    - {contextPath: FD.Contact.Id, description: ID of the contact, type: Number}
    - {contextPath: FD.Contact.JobTitle, description: Job Title of the contact, type: String}
    - {contextPath: FD.Contact.Language, description: Language of the contact, type: String}
    - {contextPath: FD.Contact.Mobile, description: Mobile number of the contact,
      type: Number}
    - {contextPath: FD.Contact.Name, description: Name of the contact, type: String}
    - {contextPath: FD.Contact.OtherEmails, description: Additional emails associated
        with the contact, type: Unknown}
    - {contextPath: FD.Contact.Phone, description: Telephone number of the contact,
      type: Number}
    - {contextPath: FD.Contact.Tags, description: Tags associated with this contact,
      type: Unknown}
    - {contextPath: FD.Contact.TimeZone, description: Time zone in which the contact
        resides, type: String}
    - {contextPath: FD.Contact.TwitterId, description: Twitter handle of the contact,
      type: String}
    - {contextPath: FD.Contact.UniqueExternalId, description: External ID of the contact,
      type: String}
    - {contextPath: FD.Contact.OtherCompanies, description: Additional companies associated
        with the contact (array of hashes), type: Unknown}
    - {contextPath: FD.Contact.CreatedAt, description: Contact creation stamp, type: Date}
    - {contextPath: FD.Contact.UpdatedAt, description: Contact updated timestamp,
      type: Date}
  - arguments: []
    description: List all Canned Response Folders (Only users with Admin Privileges)
    execution: false
    name: fd-list-cr-folders
    outputs:
    - {contextPath: FD.CRFolder.Id, description: Unique ID of the canned response
        folder, type: Number}
    - {contextPath: FD.CRFolder.Name, description: Name of the canned response folder,
      type: String}
    - {contextPath: FD.CRFolder.Personal, description: Set true if the folder can
        only be accessed by you, type: Boolean}
    - {contextPath: FD.CRFolder.ResponsesCount, description: Number of canned responses
        in the folder, type: Number}
    - {contextPath: FD.CRFolder.CreatedAt, description: Canned Response Folder's creation
        timestamp, type: Date}
    - {contextPath: FD.CRFolder.UpdatedAt, description: Canned Response Folder's updated
        timestamp, type: Date}
  - arguments:
    - default: false
      defaultValue: ''
      description: ID of the Canned Response folder for which you want to list the
        canned responses inside of it. To find the ID of a Canned Response folder,
        execute the `fd-list-cr-folders` command to see the Canned Response folders
        accessible to you.
      isArray: false
      name: id
      predefined: []
      required: true
    description: List all Canned Responses in a Folder
    execution: false
    name: fd-list-crs-in-folder
    outputs:
    - {contextPath: FD.CRFolder.CR.Id, description: ID of the Canned Response, type: Number}
    - {contextPath: FD.CRFolder.CR.Title, description: Title of the Canned Response,
      type: String}
  - arguments:
    - default: false
      defaultValue: ''
      description: ID of the Folder containing the Canned Responses you wish to view
        the details of
      isArray: false
      name: id
      predefined: []
      required: true
    description: View the details of all the Canned Responses in a Folder.
    execution: false
    name: fd-detail-crs
    outputs:
    - {contextPath: FD.CRFolder.CR.Id, description: Unique ID of the canned response,
      type: Number}
    - {contextPath: FD.CRFolder.CR.Title, description: Title of the canned response,
      type: String}
    - {contextPath: FD.CRFolder.CR.FolderId, description: ID of the containing folder,
      type: Number}
    - {contextPath: FD.CRFolder.CR.Content, description: Plaintext version of the
        canned response content, type: String}
    - {contextPath: FD.CRFolder.CR.ContentHtml, description: HTML version of the canned
        response content, type: String}
    - {contextPath: FD.CRFolder.CR.Attachments, description: Array of attachments
        associated with the canned response, type: Unknown}
  - arguments: []
    description: List all groups
    execution: false
    name: fd-list-groups
    outputs:
    - {contextPath: FD.Group.AgentIds, description: Array of agent user IDs separated
        by commas., type: Unknown}
    - {contextPath: FD.Group.AutoTicketAssign, description: Set to true if automatic
        ticket assignment has been enabled. Automatic ticket assignment is only available
        on certain plans., type: Boolean}
    - {contextPath: FD.Group.BusinessHourId, description: Unique ID of the business
        hour associated with the group, type: Number}
    - {contextPath: FD.Group.Description, description: Description of the group, type: String}
    - {contextPath: FD.Group.EscalateTo, description: The ID of the user to whom an
        escalation email is sent if a ticket is unassigned., type: Number}
    - {contextPath: FD.Group.Id, description: Unique ID of the group, type: Number}
    - {contextPath: FD.Group.Name, description: Name of the group, type: String}
    - {contextPath: FD.Group.UnassignedFor, description: 'The time after which an
        escalation email is sent if a ticket remains unassigned. The accepted values
        are "30m" for 30 minutes, "1h" for 1 hour, "2h" for 2 hours, "4h" for 4 hours,
        "8h" for 8 hours, "12h" for 12 hours, "1d" for 1 day, "2d" for 2 days, and
        "3d" for 3 days', type: String}
    - {contextPath: FD.Group.CreatedAt, description: Group creation timestamp, type: Date}
    - {contextPath: FD.Group.UpdatedAt, description: Grup updated timestamp, type: Date}
    - {contextPath: FD.Group.GroupType, description: Group Type of the group, type: String}
  - arguments:
    - default: false
      defaultValue: ''
      description: ID of the ticket you wish to respond to
      isArray: false
      name: ticket_id
      predefined: []
      required: true
    - default: false
      defaultValue: ''
      description: Content of the reply in HTML format
      isArray: false
      name: body
      predefined: []
      required: true
    - default: false
      defaultValue: ''
      description: The email address from which the reply is sent. By default the
        global support email will be used.
      isArray: false
      name: from_email
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: ID of the agent who is adding the note
      isArray: false
      name: user_id
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: Array of email address strings added in the 'cc' field of the outgoing
        ticket email.
      isArray: true
      name: cc_emails
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: Array of email address strings added in the 'bcc' field of the
        outgoing ticket email.
      isArray: true
      name: bcc_emails
      predefined: []
      required: false
    description: Reply to a specified ticket
    execution: false
    name: fd-ticket-reply
    outputs:
    - {contextPath: FD.Ticket.Conversation.Attachments, description: Array of attachments
        associated with the conversation., type: Unknown}
    - {contextPath: FD.Ticket.Conversation.Body, description: Content of the conversation
        in HTML, type: String}
    - {contextPath: FD.Ticket.Conversation.BodyText, description: Content of the conversation
        in plain text, type: String}
    - {contextPath: FD.Ticket.Conversation.Id, description: ID of the conversation,
      type: Number}
    - {contextPath: FD.Ticket.Conversation.Incoming, description: 'Set to true if
        a particular conversation should appear as being created from outside (i.e.,
        not through web portal)', type: Boolean}
    - {contextPath: FD.Ticket.Conversation.ToEmails, description: Array of email addresses
        of agents/users who need to be notified about this conversation, type: Unknown}
    - {contextPath: FD.Ticket.Conversation.Private, description: Set to true if the
        note is private, type: Boolean}
    - {contextPath: FD.Ticket.Conversation.Source, description: Denotes the type of
        conversation, type: Number}
    - {contextPath: FD.Ticket.Conversation.SupportEmail, description: 'Email address
        from which the reply is sent. For notes, this value will be null.', type: String}
    - {contextPath: FD.Ticket.Conversation.TicketId, description: ID of the ticket
        to which this conversation is being added, type: Number}
    - {contextPath: FD.Ticket.Conversation.UserId, description: ID of the agent/user
        who is adding the conversation, type: Number}
    - {contextPath: FD.Ticket.Conversation.CreatedAt, description: Conversation creation
        timestamp, type: Date}
    - {contextPath: FD.Ticket.Conversation.UpdatedAt, description: Conversation updated
        timestamp, type: Date}
    - {contextPath: FD.Ticket.Conversation.FromEmail, description: The email address
        from which the reply is sent. By default the global support email will be
        used., type: String}
  - arguments:
    - default: false
      defaultValue: ''
      description: ID of the ticket for which you would like to list all of its conversations
      isArray: false
      name: id
      predefined: []
      required: true
    description: ''
    execution: false
    name: fd-get-conversations
    outputs:
    - {contextPath: FD.Ticket.Conversation.Attachments, description: Array of attachments
        associated with the conversation., type: Unknown}
    - {contextPath: FD.Ticket.Conversation.Body, description: Content of the conversation
        in HTML, type: String}
    - {contextPath: FD.Ticket.Conversation.BodyText, description: Content of the conversation
        in plain text, type: String}
    - {contextPath: FD.Ticket.Conversation.Id, description: ID of the conversation,
      type: Number}
    - {contextPath: FD.Ticket.Conversation.Incoming, description: 'Set to true if
        a particular conversation should appear as being created from outside (i.e.,
        not through web portal)', type: Boolean}
    - {contextPath: FD.Ticket.Conversation.ToEmails, description: Array of email addresses
        of agents/users who need to be notified about this conversation, type: Unknown}
    - {contextPath: FD.Ticket.Conversation.Private, description: Set to true if the
        note is private, type: Boolean}
    - {contextPath: FD.Ticket.Conversation.Source, description: Denotes the type of
        conversation, type: Number}
    - {contextPath: FD.Ticket.Conversation.SupportEmail, description: 'Email address
        from which the reply is sent. For notes, this value will be null.', type: String}
    - {contextPath: FD.Ticket.Conversation.TicketId, description: ID of the ticket
        to which this note or reply belongs, type: Number}
    - {contextPath: FD.Ticket.Conversation.UserId, description: ID of the agent/user
        who is adding the conversation, type: Number}
    - {contextPath: FD.Ticket.Conversation.CreatedAt, description: Conversation creation
        timestamp, type: Date}
    - {contextPath: FD.Ticket.Conversation.UpdatedAt, description: Conversation updated
        timestamp, type: Date}
    - {contextPath: FD.Ticket.Conversation.FromEmail, description: The email address
        from which the reply/note is sent. By default the global support email will
        be used., type: String}
  - arguments:
    - default: false
      defaultValue: ''
      description: mobile phone number to filter agents by
      isArray: false
      name: mobile
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: telephone number to filter agents by
      isArray: false
      name: phone
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: list all agents who are either 'fulltime' or 'occasional'
      isArray: false
      name: state
      predefined: [fulltime, occasional]
      required: false
    description: List agents that match the criteria of the filters entered as command
      arguments.
    execution: false
    name: fd-list-agents
    outputs:
    - {contextPath: FD.Agent.Available, description: 'If the agent is in a group that
        has enabled "Automatic Ticket Assignment", this attribute will be set to true
        if the agent is accepting new tickets', type: Boolean}
    - {contextPath: FD.Agent.AvailableSince, description: Timestamp that denotes when
        the agent became available/unavailable (depending on the value of the 'available'
        attribute), type: Date}
    - {contextPath: FD.Agent.Id, description: User ID of the agent, type: Number}
    - {contextPath: FD.Agent.Occasional, description: 'Set to true if this is an occasional
        agent (true => occasional, false => full-time)', type: Boolean}
    - {contextPath: FD.Agent.Signature, description: Signature of the agent in HTML
        format, type: String}
    - contextPath: FD.Agent.TicketScope
      description: |-
        Ticket permission of the agent
        (1 -> Global Access, 2 -> Group Access, 3 -> Restricted Access)
      type: Number
    - {contextPath: FD.Agent.GroupIds, description: Group IDs associated with the
        agent, type: Unknown}
    - {contextPath: FD.Agent.RoleIds, description: Role IDs associated with the agent,
      type: Unknown}
    - {contextPath: FD.Agent.CreatedAt, description: Agent creation timestamp, type: Date}
    - {contextPath: FD.Agent.UpdatedAt, description: Agent updated timestamp, type: Date}
    - {contextPath: FD.Agent.Contact.Active, description: Set to true if the agent
        is verified, type: Boolean}
    - {contextPath: FD.Agent.Contact.Email, description: Email Address of the agent,
      type: String}
    - {contextPath: FD.Agent.Contact.JobTitle, description: Job title of the agent,
      type: String}
    - {contextPath: FD.Agent.Contact.Language, description: Language of the agent.
        Default language is "en", type: String}
    - {contextPath: FD.Agent.Contact.LastLoginAt, description: Timestamp of the agent's
        last successful login, type: Date}
    - {contextPath: FD.Agent.Contact.Mobile, description: Mobile number of the agent,
      type: Number}
    - {contextPath: FD.Agent.Contact.Name, description: Name of the agent, type: String}
    - {contextPath: FD.Agent.Contact.Phone, description: Telephone number of the agent,
      type: Number}
    - {contextPath: FD.Agent.Contact.TimeZone, description: Time zone of the agent,
      type: String}
    - {contextPath: FD.Agent.Contact.CreatedAt, description: Creation timestamp, type: Date}
    - {contextPath: FD.Agent.Contact.UpdatedAt, description: Timestamp of the last
        update, type: Date}
    - {contextPath: FD.Agent.Type, description: Type of agent, type: String}
  - arguments:
    - default: false
      defaultValue: ''
      description: ID of the ticket you wish to make a note for
      isArray: false
      name: ticket_id
      predefined: []
      required: true
    - default: false
      defaultValue: ''
      description: Content of the note in HTML format
      isArray: false
      name: body
      predefined: []
      required: true
    - default: false
      defaultValue: ''
      description: Set to false if the note is not private
      isArray: false
      name: private
      predefined: ['True', 'False']
      required: false
    - default: false
      defaultValue: ''
      description: ID of the agent who is adding the note
      isArray: false
      name: user_id
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: Array of email addresses of agents/users who need to be notified
        about this note
      isArray: true
      name: notify_emails
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: Set to true if a particular note should appear as being created
        from outside (i.e., not through web portal).
      isArray: false
      name: incoming
      predefined: ['True', 'False']
      required: false
    description: Create a note for a specified ticket. By default any note you add
      will be private unless you set the 'private' command argument to False.
    execution: false
    name: fd-ticket-note
    outputs:
    - {contextPath: FD.Ticket.Conversation.Attachments, description: Array of attachments
        associated with the conversation., type: Unknown}
    - {contextPath: FD.Ticket.Conversation.Body, description: Content of the conversation
        in HTML, type: String}
    - {contextPath: FD.Ticket.Conversation.BodyText, description: Content of the conversation
        in plain text, type: String}
    - {contextPath: FD.Ticket.Conversation.Id, description: ID of the conversation,
      type: Number}
    - {contextPath: FD.Ticket.Conversation.Incoming, description: 'Set to true if
        a particular conversation should appear as being created from outside (i.e.,
        not through web portal)', type: Boolean}
    - {contextPath: FD.Ticket.Conversation.ToEmails, description: Array of email addresses
        of agents/users who need to be notified about this conversation, type: Unknown}
    - {contextPath: FD.Ticket.Conversation.Private, description: Set to true if the
        note is private, type: Boolean}
    - {contextPath: FD.Ticket.Conversation.Source, description: Denotes the type of
        conversation, type: Number}
    - {contextPath: FD.Ticket.Conversation.SupportEmail, description: 'Email address
        from which the reply is sent. For notes, this value will be null.', type: String}
    - {contextPath: FD.Ticket.Conversation.TicketId, description: ID of the ticket
        to which this conversation is being added, type: Number}
    - {contextPath: FD.Ticket.Conversation.UserId, description: ID of the agent/user
        who is adding the conversation, type: Number}
    - {contextPath: FD.Ticket.Conversation.CreatedAt, description: Conversation creation
        timestamp, type: Date}
    - {contextPath: FD.Ticket.Conversation.UpdatedAt, description: Conversation updated
        timestamp, type: Date}
    - {contextPath: FD.Ticket.Conversation.FromEmail, description: The email address
        from which the reply/note is sent. By default the global support email will
        be used., type: String}
  - arguments:
    - default: false
      defaultValue: ''
      description: ID of the ticket to delete
      isArray: false
      name: id
      predefined: []
      required: true
    description: Delete the ticket specified by the 'id' command argument
    execution: false
    name: fd-delete-ticket
    outputs: []
  dockerimage: ''
  isfetch: false
  runonce: false
  script: |-
    import demistomock as demisto
    from CommonServerPython import *
    from CommonServerUserPython import *
    ''' IMPORTS '''

    import json
    import requests
    from distutils.util import strtobool

    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    ''' GLOBALS/PARAMS '''

    CREDS = demisto.params().get('credentials')
    USERNAME = CREDS.get('identifier') if CREDS else None
    PASSWORD = CREDS.get('password') if CREDS else None
    TOKEN = demisto.params().get('token')

    if not (USERNAME and PASSWORD) and not TOKEN:
        err_msg = "You must provide either your freshdesk account API key or the " \
                  "username and password you use to sign into your freshdesk account " \
                  "when instantiating an instance of the freshdesk integration."
        return_error(err_msg)

    AUTH = (TOKEN, 'X') if TOKEN else (USERNAME, PASSWORD)

    # Remove trailing slash to prevent wrong URL path to service
    SERVER = demisto.params()['url'][:-1] if (demisto.params()['url'] and demisto.params()['url'].endswith('/')) else demisto.params()['url']
    # Should we use SSL
    USE_SSL = not demisto.params().get('unsecure', False)
    # Service base URL
    BASE_URL = SERVER + '/api/v2/'
    # Headers to be sent in requests
    HEADERS = {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    }
    # Remove proxy if not set to true in params
    if not demisto.params().get('proxy'):
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']


    ''' HELPER FUNCTIONS '''


    def entries_to_files(entry_ids):
        attachments = []
        for entry_id in entry_ids:
            execute_results = demisto.getFilePath(entry_id)
            file_path = execute_results["path"]
            file_name = execute_results["name"]
            attachments.append(('attachments[]', (file_name, open(file_path, 'rb'))))

        return attachments


    def handle_array_input(args):
        array_inputs = ['tags', 'attachments', 'cc_emails', 'bcc_emails', 'to_emails', 'update_fields', 'update_values']

        for arr_input in array_inputs:
            if arr_input in args.keys():
                args[arr_input] = argToList(args.get(arr_input))

        return args


    def handle_bool_input(args):
        bool_inputs = ['private', 'incoming']
        acceptable_vals = ['true', 'false']

        try:
            for bool_input in bool_inputs:
                if bool_input in args.keys():
                    args[bool_input] = args.get(bool_input).lower()
                    if args[bool_input] not in acceptable_vals:
                        raise ValueError('field: "{}"\n'.format(bool_input))
        except ValueError as e:
            return_error(e.message + 'The only valid inputs for this field are either "True" or "False"')

        return args


    def validate_priority_input(args):
        # Parse and ensure valid command argument
        priority = args.get('priority', None)

        # If priority wasn't given by the user as a cmd arg
        # then no need to alter it to API expectations
        if not priority:
            return args

        priorities = ['low', 'medium', 'high', 'urgent']

        # Check if the user entered status as words - aka the
        # options listed above in 'statuses'
        err_msg = "priority should be one of these values: 1, 2, 3, 4, {}".format(', '.join(priorities))
        if len(priority) > 1:
            if priority.lower() in priorities:
                # Add 1 since API status numbers for tickets start at 1
                # Cast to string so clean_arguments helper function doesn't throw any errors
                args['priority'] = str(priorities.index(priority.lower()) + 2)
            else:
                return_error(err_msg)
        # Otherwise make sure the user entered valid status number
        elif not (0 < int(priority) < 5):
            return_error(err_msg)
        return args


    def validate_status_input(args):
        # Parse and ensure valid command argument
        status = args.get('status', None)

        # If status wasn't given by the user as a cmd arg
        # then no need to alter it to API expectations
        if not status:
            return args

        statuses = [
            'open', 'pending', 'resolved', 'closed',
            'waiting on customer', 'waiting on third party'
        ]

        # Check if the user entered status as words - aka the
        # options listed above in 'statuses'
        err_msg = "status should be one of these values: 2, 3, 4, 5, 6, 7, {}".format(', '.join(statuses))
        if len(status) > 1:
            if status.lower() in statuses:
                # Add 2 since API status numbers for tickets start at 2
                # Cast to string so clean_arguments helper function doesn't throw any errors
                args['status'] = str(statuses.index(status.lower()) + 2)
            else:
                return_error(err_msg)
        # Otherwise make sure the user entered valid status number
        elif not (1 < int(status) < 8):
            return_error(err_msg)
        return args


    def clean_arguments(args):
        args = validate_status_input(args)
        args = validate_priority_input(args)
        args = handle_array_input(args)

        # Command args that should be numbers
        number_args = [
            'requester_id', 'status', 'priority', 'responder_id',
            'email_config_id', 'group_id', 'product_id', 'source', 'company_id'
        ]
        # Convert cmd args that are expected to be numbers from strings to numbers
        for num_arg in number_args:
            if num_arg in args.keys():
                args[num_arg] = int(args.get(num_arg))
        return args


    def determine_identifier(args):
        identifier = args.get('identifier')
        if identifier.startswith('@'):
            # Then it's a twitter handle
            args['twitter_id'] = identifier
        else:
            # Otherwise assume it's an email address
            args['email'] = identifier
        # Delete identifier field from args since it doesn't match API expected inputs
        del args['identifier']
        return args


    # Adjust this function to use determine_agent and determine_group functions
    def determine_responder(args):
        responder = args.get('responder', None)
        if responder:
            group_names = []
            group_ids = []
            groups = list_groups()
            # Get names and ids of groups
            for group in groups:
                group_ids.append(group.get('id'))
                group_names.append(group.get('name').lower())
            # Check if responder value is a group ID
            if responder in group_ids:
                args['group_id'] = responder
            # Or the name of a group
            elif responder.lower() in group_names:
                args['group_id'] = group_ids[group_names.index(responder.lower())]

            agent_names = []
            agent_ids = []
            # Get names and ids of agents
            agents = list_agents({})
            for agent in agents:
                agent_ids.append(agent.get('id'))
                agent_names.append(agent.get('contact').get('name').lower())
            # Check if responder value is a contact ID
            if responder in agent_ids:
                args['responder_id'] = responder
            elif responder.lower() in agent_names:
                args['responder_id'] = agent_ids[agent_names.index(responder.lower())]

            # Delete responder field from args since it doesn't match API expected inputs
            del args['responder']
        return args


    def determine_agent(args, key_name):
        assigned_agent = args.get(key_name, None)
        if assigned_agent:
            agent_emails, agent_names, agent_ids = [], [], []
            # Get names, emails and ids of agents
            agents = list_agents({})
            for agent in agents:
                agent_ids.append(agent.get('id'))
                agent_names.append(agent.get('contact').get('name').lower())
                agent_emails.append(agent.get('contact').get('email').lower())
            # Check if responder value is a contact ID
            if assigned_agent in agent_ids:
                args['responder_id'] = assigned_agent
                # Delete assigned_agent field from args since it doesn't match API expected inputs
                del args[key_name]
            elif assigned_agent.lower() in agent_names:
                args['responder_id'] = agent_ids[agent_names.index(assigned_agent.lower())]
                del args[key_name]
            elif assigned_agent.lower() in agent_emails:
                args['responder_id'] = agent_ids[agent_emails.index(assigned_agent.lower())]
                del args[key_name]

        return args


    def determine_group(args, key_name):
        assigned_group = args.get(key_name, None)
        if assigned_group:
            group_names, group_ids = [], []
            # Get names and ids of groups
            groups = list_groups()
            for group in groups:
                group_ids.append(group.get('id'))
                group_names.append(group.get('name').lower())
            # Check if responder value is a group ID
            if assigned_group in group_ids:
                args['group_id'] = assigned_group
                del args[key_name]
            # Or the name of a group
            elif assigned_group.lower() in group_names:
                args['group_id'] = group_ids[group_names.index(assigned_group.lower())]
                del args[key_name]
        return args


    def http_request(method, url_suffix, params=None, data=None, files=None):
        # A wrapper for requests lib to send our requests and handle requests and responses better
        res = requests.request(
            method,
            BASE_URL + url_suffix,
            verify=USE_SSL,
            params=params,
            data=data,
            headers=HEADERS,
            auth=AUTH,
            files=files
        )
        # Handle error responses gracefully
        if res.status_code not in [200, 201, 202, 204]:
            LOG(res.json())
            LOG(res.text)
            LOG.print_log()
            err_msg = 'Error in API call to Freshdesk Integration [{}] - {}'.format(res.status_code, res.reason)
            err = json.loads(res.content)
            if err.get('errors'):
                for error in err.get('errors'):
                    err_msg += '\n' + json.dumps(error, indent=2)
            else:
                for key, value in res.json().iteritems():
                    err_msg += '\n{}: {}'.format(key, value)
            return_error(err_msg)

        return res.json()


    ''' COMMANDS + REQUESTS FUNCTIONS '''


    def test_module():
        """
        Performs basic get request to get item samples
        """
        ticket_id = '1'
        response = http_request('GET', 'tickets/{}'.format(ticket_id))


    '''<------ TICKETS ------>'''


    def create_ticket(args):
        args = clean_arguments(args)
        args = determine_identifier(args)
        args = determine_responder(args)
        endpoint_url = 'tickets'

        response = None
        if not args.get('attachments'):
            # The service endpoint to request from
            # Send a request using our http_request wrapper
            response = http_request('POST', endpoint_url, data=json.dumps(args))
        else:
            # Set global HEADERS to the correct content type
            global HEADERS
            del HEADERS['Content-Type']
            # Get the files from their entry IDs
            attachments = entries_to_files(args.get('attachments'))
            # Format to API expectations
            del args['attachments']
            # Send a request and get raw response
            response = http_request('POST', endpoint_url, data=args, files=attachments)
            # Update HEADERS back to their norm
            HEADERS['Content-Type'] = 'application/json'
        return response


    def create_ticket_command():
        """
        One line summary.

        demisto parameter: (string) name
            Name of the requester

        demisto parameter: (number) requester_id
            User ID of the requester. For existing contacts, the
            requester_id can be passed instead of the requester's email.

        demisto parameter: (string) email
            Email address of the requester. If no contact exists with
            this email address in Freshdesk, it will be added as a new contact.

        demisto parameter: (string) facebook_id
            Facebook ID of the requester. If no contact exists with this
            facebook_id, then a new contact will be created.

        demisto parameter: (string) phone
            Phone number of the requester. If no contact exists with this
            phone number in Freshdesk, it will be added as a new contact.
            If the phone number is set and the email address is not, then
            the name attribute is mandatory.

        demisto parameter: (string) twitter_id
            Twitter handle of the requester. If no contact exists with this
            handle in Freshdesk, it will be added as a new contact.

        demisto parameter: (string) unique_external_id
            External ID of the requester. If no contact exists with this
            external ID in Freshdesk, they will be added as a new contact.

        demisto parameter: (string) subject
            Subject of the ticket. The default Value is null.

        demisto parameter: (string) type
            Helps categorize the ticket according to the different kinds of
            issues your support team deals with. The default Value is null.

        demisto parameter: (number) status
            Status of the ticket. The default Value is 2.

        demisto parameter: (number) priority
            Priority of the ticket. The default value is 1.

        demisto parameter: (string) description
            HTML content of the ticket.

        demisto parameter: (number) responder_id
            ID of the agent to whom the ticket has been assigned

        demisto parameter: (array) attachments
            Ticket attachments. The total size of these attachments cannot exceed 15MB.

        demisto parameter: (array) cc_emails
            Email address added in the 'cc' field of the incoming ticket email

        demisto parameter: (dict) custom_fields
            Key value pairs containing the names and values of custom fields.

        demisto parameter: (datetime) due_by
            Timestamp that denotes when the ticket is due to be resolved

        demisto parameter: (number) email_config_id
            ID of email config which is used for this ticket. (i.e.,
            support@yourcompany.com/sales@yourcompany.com) If product_id
            is given and email_config_id is not given, product's primary
            email_config_id will be set

        demisto parameter: (datetime) fr_due_by
            Timestamp that denotes when the first response is due

        demisto parameter: (number) group_id
            ID of the group to which the ticket has been assigned. The default
            value is the ID of the group that is associated with the given email_config_id

        demisto parameter: (number) product_id
            ID of the product to which the ticket is associated. It will be
            ignored if the email_config_id attribute is set in the request.

        demisto parameter: (number) source
            The channel through which the ticket was created. The default value is 2.

        demisto parameter: (array) tags
            Tags that have been associated with the ticket

        demisto parameter: (number) company_id
            Company ID of the requester. This attribute can only be set if the
            Multiple Companies feature is enabled

        returns:
            Ticket (JSON) object
        """
        # Get command arguments from user
        args = demisto.args()
        # Make request and get raw response
        ticket = create_ticket(args)
        # Parse response into context
        include_in_context = [
            'priority', 'due_by', 'subject', 'attachments', 'status',
            'requester_id', 'tags', 'group_id', 'source', 'created_at',
            'responder_id', 'fr_due_by', 'id'
        ]
        context = {string_to_context_key(key): val for key, val in ticket.iteritems() if key in include_in_context}
        # Parse attachments into context
        attachments_context = []
        for attachment in context['Attachments']:
            attachment_context = {string_to_context_key(key): val for key, val in attachment.iteritems()}
            attachments_context.append(attachment_context)
        context['Attachments'] = attachments_context
        title = "Newly Created Ticket #{}".format(context.get('Id'))
        md = tableToMarkdown(title, context, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': ticket,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                'FD.Ticket(val.Id && val.Id === obj.Id)': context
            }
        })


    def update_ticket(args):
        # Get ticket number
        ticket_number = args.get('id')
        # Remove ticket number from args
        del args['id']

        args = determine_agent(args, 'assigned_agent')
        args = determine_group(args, 'assigned_group')

        # Format args according to API expecations
        additional_update_fields = args.get('update_fields')
        additional_field_values = args.get('update_values')
        for field, value in zip(additional_update_fields, additional_field_values):
            # if field == 'tags':
            #     demisto.results('The type of the tags value is: {}'.format(type(value)))
            args[field] = value
        del args['update_fields']
        del args['update_values']

        # demisto.results('args preclean: {}'.format(args))

        args = clean_arguments(args)
        # demisto.results('args postclean: {}'.format(args))

        # The service endpoint to request from
        endpoint_url = 'tickets/{}'.format(ticket_number)

        response = None
        if not args.get('attachments'):
            # Send a request using our http_request wrapper
            response = http_request('PUT', endpoint_url, data=json.dumps(args))
        else:
            # Set global HEADERS to the correct content type
            global HEADERS
            del HEADERS['Content-Type']
            # Get the files from their entry IDs
            attachments = entries_to_files(args.get('attachments'))
            # Format to API expectations
            del args['attachments']
            # Send a request and get raw response
            response = http_request('PUT', endpoint_url, data=args, files=attachments)
            # Update HEADERS back to their norm
            HEADERS['Content-Type'] = 'application/json'
        return response


    def update_ticket_command():
        args = demisto.args()
        additional_update_fields = argToList(args.get('update_fields'))
        additional_field_values = argToList(args.get('update_values'))

        # Handle sublists in command line arg of 'update_fields'
        in_sublist = False
        tmp_list = []
        sublist = []
        for i, val in enumerate(additional_field_values):
            if val.startswith('['):
                in_sublist = True
                sublist.append(val[1:])
            elif val.endswith(']'):
                sublist.append(val[:-1])
                tmp_list.append(sublist[:])
                del sublist[:]
                in_sublist = False
            elif in_sublist:
                sublist.append(val)
            else:
                tmp_list.append(val)
        additional_field_values = tmp_list
        args['update_values'] = additional_field_values
        args['update_fields'] = additional_update_fields

        if len(additional_update_fields) != len(additional_field_values):
            err_msg = "The 'update_fields' list and 'update_values' list command arguments"
            err_msg += " must contain the same number of items."
            err_msg += "\nlength of 'update_fields' list: {}".format(len(additional_update_fields))
            err_msg += "\nlength of 'update_values' list: {}".format(len(additional_field_values))
            return_error(err_msg)
        # Make request and get raw response
        ticket = update_ticket(args)
        # Parse response into context
        include_in_context = [
            'priority', 'due_by', 'subject', 'attachments', 'status',
            'requester_id', 'tags', 'group_id', 'source', 'created_at',
            'responder_id', 'fr_due_by', 'updated_at', 'id'
        ]
        # Make sure not to double add certain fields to context, aka the fields that
        # have been relegated to the update_fields argument but have their own context output
        intersection = list(set(additional_update_fields) & set(include_in_context))
        for field in intersection:
            idx = additional_update_fields.index(field)
            additional_update_fields.pop(idx)
            additional_field_values.pop(idx)

        context = {string_to_context_key(key): val for key, val in ticket.iteritems() if key in include_in_context}
        # Parse additional fields into context
        additional_field_contexts = []
        for field, value in zip(additional_update_fields, additional_field_values):
            field_context = {string_to_context_key(field): value}
            additional_field_contexts.append(field_context)
        context['UpdatedField'] = additional_field_contexts
        # Parse attachments into context
        attachments_context = []
        for attachment in context['Attachments']:
            attachment_context = {string_to_context_key(key): val for key, val in attachment.iteritems()}
            attachments_context.append(attachment_context)
        context['Attachments'] = attachments_context
        title = "Ticket #{} Updated".format(context.get('Id'))
        md = tableToMarkdown(title, context, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': ticket,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                'FD.Ticket(val.Id && val.Id === obj.Id)': context
            }
        })


    def view_ticket(ticket_number):
        endpoint_url = 'tickets/{}'.format(ticket_number)
        response = http_request('GET', endpoint_url)
        return response


    def view_ticket_command():
        # Get command arguments from user
        ticket_number = demisto.args().get('id')
        # Make request and get raw response
        ticket = view_ticket(ticket_number)
        # Parse response into context
        context = {string_to_context_key(key): val for key, val in ticket.iteritems()}
        # Parse attachments into context
        attachments_context = []
        for attachment in context['Attachments']:
            attachment_context = {string_to_context_key(key): val for key, val in attachment.iteritems()}
            attachments_context.append(attachment_context)
        context['Attachments'] = attachments_context
        title = "Viewing Ticket #{}".format(ticket_number)
        md = tableToMarkdown(title, context, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': ticket,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                'FD.Ticket(val.Id && val.Id === obj.Id)': context
            }
        })


    def delete_ticket(ticket_id):
        global HEADERS
        HEADERS['USER-AGENT'] = "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.82 Safari/537.36"
        endpoint_url = 'tickets/{}'.format(ticket_id)
        demisto.results('working after making endpoint_url')
        response = http_request('DELETE', endpoint_url)
        demisto.results('working after making delete request')
        del HEADERS['USER-AGENT']
        return response


    def delete_ticket_command():
        ticket_id = demisto.args().get('id')
        delete_forever = demisto.args().get('delete_forever')
        demisto.results('working after getting args')
        # Make request
        response = delete_ticket(ticket_id)
        if delete_forever.lower() == 'true':
            response = delete_ticket_forever(ticket_id)
            message = "Deleted Ticket #{} Forever".format(ticket_id)
        else:
            message = "Soft-Deleted Ticket #{}".format(ticket_id)
        demisto.results(message)


    '''<------ CONVERSATIONS ------>'''


    def ticket_reply(args):
        ticket_id = args.get('ticket_id')
        del args['ticket_id']
        args = handle_array_input(args)
        endpoint_url = 'tickets/{}/reply'.format(ticket_id)

        # Handle potential attachments
        response = None
        if not args.get('attachments'):
            # The service endpoint to request from
            # Send a request using our http_request wrapper
            response = http_request('POST', endpoint_url, data=json.dumps(args))
        else:
            # Set global HEADERS to the correct content type
            global HEADERS
            del HEADERS['Content-Type']
            # Get the files from their entry IDs
            attachments = entries_to_files(args.get('attachments'))
            # Format to API expectations
            del args['attachments']
            # Send a request and get raw response
            response = http_request('POST', endpoint_url, data=args, files=attachments)
            # Update HEADERS back to their norm
            HEADERS['Content-Type'] = 'application/json'
        return response


    def ticket_reply_command():
        args = demisto.args()
        # Make request and get raw response
        reply = ticket_reply(args)
        # Parse response into context
        context = {string_to_context_key(key): val for key, val in reply.iteritems()}
        # Parse attachments into context
        attachments_context = []
        for attachment in context['Attachments']:
            attachment_context = {string_to_context_key(key): val for key, val in attachment.iteritems()}
            attachments_context.append(attachment_context)
        context['Attachments'] = attachments_context
        title = "Reply to Ticket #{}".format(reply.get('ticket_id'))
        md = tableToMarkdown(title, context, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': reply,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                'FD.Ticket(val.Id && val.Id === obj.Id).Conversation(val.Id && val.Id === obj.Id)': context
            }
        })


    def ticket_note(args):
        ticket_id = args.get('ticket_id')
        del args['ticket_id']
        args = handle_array_input(args)
        # Set defaults for 'private' and 'incoming' fields if not set by user
        args['private'] = args.get('private', 'True')
        args['incoming'] = args.get('incoming', 'False')
        args = handle_bool_input(args)
        endpoint_url = 'tickets/{}/notes'.format(ticket_id)

        demisto.results('args jsondumped: {}'.format(json.dumps(args)))
        demisto.results('args not dumped: {}'.format(args))
        demisto.results('load of jsondumped args: {}'.format(json.loads(json.dumps(args))))

        response = None
        if not args.get('attachments'):
            # The service endpoint to request from
            # Send a request using our http_request wrapper
            response = http_request('POST', endpoint_url, data=json.dumps(args))
        else:
            # Set global HEADERS to the correct content type
            global HEADERS
            del HEADERS['Content-Type']
            # Get the files from their entry IDs
            attachments = entries_to_files(args.get('attachments'))
            # Format to API expectations
            del args['attachments']
            # Send a request and get raw response
            response = http_request('POST', endpoint_url, data=args, files=attachments)
            # Update HEADERS back to their norm
            HEADERS['Content-Type'] = 'application/json'
        return response


    def ticket_note_command():
        # Get command arguments
        args = demisto.args()
        # Make request and get raw response
        note = ticket_note(args)
        # Parse response into context
        context = {string_to_context_key(key): val for key, val in note.iteritems()}
        # Parse attachments into context
        attachments_context = []
        for attachment in context['Attachments']:
            attachment_context = {string_to_context_key(key): val for key, val in attachment.iteritems()}
            attachments_context.append(attachment_context)
        context['Attachments'] = attachments_context
        title = 'Note for Ticket #{}'.format(note.get('ticket_id'))
        md = tableToMarkdown(title, context, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': note,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                'FD.Ticket(val.Id && val.Id === obj.Id).Conversation(val.Id && val.Id === obj.Id)': context
            }
        })


    def get_conversations(ticket_id):
        endpoint_url = 'tickets/{}/conversations'.format(ticket_id)
        response = http_request('GET', endpoint_url)
        return response


    def get_conversations_command():
        # Get id number of ticket as cmd arg for which you want to see all the conversations
        ticket_id = demisto.args().get('id')
        # Make request and get raw response
        conversations = get_conversations(ticket_id)
        # Parse response into context
        contexts = []
        for conversation in conversations:
            context = {string_to_context_key(key): val for key, val in conversation.iteritems()}
            # Parse attachments into context
            attachments_context = []
            for attachment in context['Attachments']:
                attachment_context = {string_to_context_key(key): val for key, val in attachment.iteritems()}
                attachments_context.append(attachment_context)
            context['Attachments'] = attachments_context
            contexts.append(context)
        title = 'Conversations of Ticket #{}'.format(ticket_id)
        md = tableToMarkdown(title, contexts, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': conversations,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                'FD.Ticket(val.Id && val.Id === obj.Id).Conversation(val.Id && val.Id === obj.Id)': contexts
            }
        })


    '''<------ CONTACTS ------>'''


    def list_contacts(filters):
        # Alter to match API expected inputs
        updated_since = filters.get('updated_since', None)
        if updated_since:
            del filters['updated_since']
            filters['_updated_since'] = updated_since

        endpoint_url = 'contacts'
        response = http_request('GET', endpoint_url, params=filters)
        return response


    def list_contacts_command():
        # Get command arguments from user
        filters = demisto.args()
        # Make request and get raw response
        contacts = list_contacts(filters)
        # Parse response into context
        contexts = []
        for contact in contacts:
            # Parse individual contact response in context
            context = {string_to_context_key(key): val for key, val in contact.iteritems()}
            contexts.append(context)
        filters_as_strings = ', '.join(['{}: {}'.format(key, val) for key, val in filters.iteritems()])
        title = "Contacts Filtered by {}".format(filters_as_strings) if filters else "All Contacts"
        md = tableToMarkdown(title, contexts, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contacts,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                'FD.Contact(val.Id && val.Id === obj.Id)': contexts
            }
        })


    def view_contact(args):
        contact_id = 0
        if not args:
            err_msg = 'You must provide a value for either the mobile, email or id command argument fields.'
            return_error(err_msg)
        elif args.get('id') is not None:
            contact_id = args.get('id')
        elif args.get('email') is not None:
            try:
                filters = {'email': args.get('email')}
                # Get id field of first result of contacts with that email (There should only be one)
                contact_id = list_contacts(filters)[0].get('id')
            # If there is an IndexError, it means no results were returned for the given filter
            except IndexError as e:
                err_msg = "Couldn't find a contact with that email address."\
                            " Double check that you wrote the email address correctly"\
                            " and/or that you have a FreshDesk contact with that exact"\
                            " email address."
                return_error(err_msg)
            except Exception as e:
                return_error(e.message)
        else:
            try:
                filters = {'mobile': args.get('mobile')}
                # Get id field of first result of contacts with that mobile number
                contact_id = list_contacts(filters)[0].get('id')
            # If there is an IndexError, it means no results were returned for the given filter
            except IndexError as e:
                err_msg = "Couldn't find a contact with that mobile number."\
                        " Double check that you wrote it correctly and/or that "\
                        "you have a FreshDesk contact with that exact mobile number."
                return_error(err_msg)
            except Exception as e:
                return_error(e.message)

        endpoint_url = 'contacts/{}'.format(contact_id)
        response = http_request('GET', endpoint_url)
        return response


    def view_contact_command():
        # Get command arguments from user
        # contact_id = demisto.args().get('id')
        args = demisto.args()
        # Make request and get raw response
        contact = view_contact(args)
        # Parse response into context
        context = {string_to_context_key(key): val for key, val in contact.iteritems()}
        title = "Viewing Contact #{}".format(contact.get('id'))
        md = tableToMarkdown(title, context, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contact,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                'FD.Contact(val.Id && val.Id === obj.Id)': context
            }
        })


    '''<------ CANNED RESPONSES ------>'''


    def list_cr_folders():
        endpoint_url = 'canned_response_folders'
        response = http_request('GET', endpoint_url)
        return response


    def list_cr_folders_command():
        # Make request and get raw response
        cr_folders = list_cr_folders()
        # Parse response into context
        contexts = []
        for folder in cr_folders:
            # Parse individual contact response in context
            context = {string_to_context_key(key): val for key, val in folder.iteritems()}
            contexts.append(context)
        title = "All Canned Response Folders"
        md = tableToMarkdown(title, contexts, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': cr_folders,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                'FD.CRFolder(val.Id && val.Id === obj.Id)': contexts
            }
        })


    def list_crs_in_folder(id):
        endpoint_url = 'canned_response_folders/{}'.format(id)
        response = http_request('GET', endpoint_url)
        return response


    def list_crs_in_folder_command():
        # Get id of the containing canned response folder as cmd argument
        cr_folder_id = demisto.args().get('id')
        # Make request and get raw response
        canned_responses = list_crs_in_folder(cr_folder_id)
        # Parse response into context
        contexts = []
        for cr in canned_responses.get('canned_responses'):
            context = {string_to_context_key(key): val for key, val in cr.iteritems()}
            contexts.append(context)
        title = "Canned Responses in Folder #{}".format(canned_responses.get('id'))
        md = tableToMarkdown(title, contexts, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': canned_responses,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                'FD.CRFolder(val.Id && val.Id === obj.Id).CR(val.Id && val.Id === obj.Id)': contexts
            }
        })


    def detail_crs(id):
        endpoint_url = 'canned_response_folders/{}/responses'.format(id)
        response = http_request('GET', endpoint_url)
        return response


    def detail_crs_command():
        # Get id of the containing canned response folder as cmd argument
        cr_folder_id = demisto.args().get('id')
        # Make request and get raw response
        canned_responses = detail_crs(cr_folder_id)
        # Parse the responses into context
        contexts = []
        for cr in canned_responses:
            context = {string_to_context_key(key): val for key, val in cr.iteritems()}
            contexts.append(context)
        title = "Details of Canned Responses in CR Folder #{}".format(cr_folder_id)
        md = tableToMarkdown(title, contexts, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': canned_responses,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                'FD.CRFolder(val.Id && val.Id === obj.Id).CR(val.Id && val.Id === obj.Id)': contexts
            }
        })


    '''<------ GROUPS ------>'''


    def list_groups():
        endpoint_url = 'groups'
        response = http_request('GET', endpoint_url)
        return response


    def list_groups_command():
        # Make request and get raw response
        groups = list_groups()
        # Parse response into context
        contexts = []
        for group in groups:
            # Parse individual group response in context
            context = {string_to_context_key(key): val for key, val in group.iteritems()}
            contexts.append(context)
        title = "All Groups"
        md = tableToMarkdown(title, contexts, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': groups,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                'FD.Group(val.Id && val.Id === obj.Id)': contexts
            }
        })


    '''<------ AGENTS ------>'''


    def list_agents(filters):
        endpoint_url = 'agents'
        response = http_request('GET', endpoint_url, params=filters)
        return response


    def list_agents_command():
        # Get filter as cmd arg
        args = demisto.args()
        # Make request and get raw response
        agents = list_agents(args)
        # Parse response into context
        contexts = []
        for agent in agents:
            # Parse the individual agent into context
            context = {string_to_context_key(key): val for key, val in agent.iteritems()}
            context['Contact'] = {string_to_context_key(key): val for key, val in context.get('Contact').iteritems()}
            contexts.append(context)
        title = "All Agents"
        md = tableToMarkdown(title, contexts, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': agents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                'FD.Agent(val.Id && val.Id === obj.Id)': contexts
            }
        })


    ''' COMMANDS MANAGER / SWITCH PANEL '''


    # Commands Switch Panel
    commands = {
        "fd-create-ticket": create_ticket_command,
        "fd-update-ticket": update_ticket_command,
        "fd-view-ticket": view_ticket_command,
        "fd-view-contact": view_contact_command,
        "fd-list-contacts": list_contacts_command,
        "fd-list-cr-folders": list_cr_folders_command,
        "fd-list-crs-in-folder": list_crs_in_folder_command,
        "fd-detail-crs": detail_crs_command,
        "fd-list-groups": list_groups_command,
        "fd-ticket-reply": ticket_reply_command,
        "fd-ticket-note": ticket_note_command,
        "fd-get-conversations": get_conversations_command,
        "fd-list-agents": list_agents_command,
        "fd-delete-ticket": delete_ticket_command,
    }

    LOG('Command being called is %s' % (demisto.command()))

    try:
        if demisto.command() == 'test-module':
            # This is the call made when pressing the integration test button.
            test_module()
            demisto.results('ok')
        elif demisto.command() in commands.keys():
            # Execute that command
            commands[demisto.command()]()

    # Log exceptions
    except Exception as e:
        return_error(e.message)
  type: python
