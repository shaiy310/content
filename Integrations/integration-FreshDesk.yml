category: Ticketing
commonfields: {id: Freshdesk, version: -1}
configuration:
- defaultvalue: https://example.net
  display: Server URL (e.g. https://example.net)
  name: url
  options: []
  required: true
  type: 0
- defaultvalue: ''
  display: API Token
  name: token
  options: []
  required: false
  type: 4
- defaultvalue: 'true'
  display: Trust any certificate (unsecure)
  name: insecure
  options: []
  required: false
  type: 8
- defaultvalue: ''
  display: Use system proxy
  name: proxy
  options: []
  required: false
  type: 8
- defaultvalue: 3 days
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days)
  name: fetch_time
  options: []
  required: false
  type: 0
- defaultvalue: ''
  display: Username
  name: credentials
  options: []
  required: false
  type: 9
description: Freshdesk Integration
detaileddescription: Use these detailed instructions in order to retrieve the API
  key
display: Freshdesk
name: Freshdesk
script:
  commands:
  - arguments:
    - default: false
      defaultValue: ''
      description: Subject of the ticket. The default Value is null.
      isArray: false
      name: subject
      predefined: []
      required: true
    - default: false
      defaultValue: ''
      description: Details of the issue for which you are creating a ticket.
      isArray: false
      name: description
      predefined: []
      required: true
    - default: false
      defaultValue: '1'
      description: Priority of the ticket. Each number has a corresponding value.
        1 is Low, 2 is Medium, 3 is High, 4 is Urgent.
      isArray: false
      name: priority
      predefined: ['1', '2', '3', '4']
      required: false
    - default: false
      defaultValue: '2'
      description: Status of the ticket. Each number has a corresponding value. 2
        is Open, 3 is Pending, 4 is Resolved, 5 is Closed, 6 is Waiting on Customer,
        7 is Waiting on Third Party.
      isArray: false
      name: status
      predefined: ['2', '3', '4', '5', '6', '7']
      required: false
    - default: false
      defaultValue: ''
      description: This can be an email address or a twitter handle
      isArray: false
      name: identifier
      predefined: []
      required: true
    - default: false
      defaultValue: ''
      description: ID or name of the group or agent to whom you wish to assign this
        ticket. To find potential assignees, try executing the fd-list-groups command.
      isArray: false
      name: responder
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: Entry IDs of files to attach to the ticket. The total size of these
        attachments cannot exceed 15MB.
      isArray: true
      name: attachments
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: List of ticket fields you wish to enter the value for.
      isArray: true
      name: additional_fields
      predefined: [name, requester_id, facebook_id, phone, unique_external_id, type,
        cc_emails, custom_fields, due_by, email_config_id, fr_due_by, product_id,
        source, tags, company_id, email, twitter_id, responder_id, group_id]
      required: false
    - default: false
      defaultValue: ''
      description: List of values that are assigned to the field at the same list
        index in the additional_fields argument.
      isArray: true
      name: additional_values
      predefined: []
      required: false
    description: Create a new Freshdesk ticket.
    execution: false
    name: fd-create-ticket
    outputs:
    - {contextPath: FD.Ticket.Priority, description: Priority of the ticket, type: Number}
    - {contextPath: FD.Ticket.DueBy, description: Timestamp that denotes when the
        ticket is due to be resolved, type: Date}
    - {contextPath: FD.Ticket.Subject, description: Subject of the ticket, type: String}
    - {contextPath: FD.Ticket.Attachments, description: Ticket attachments. The total
        size of these attachments cannot exceed 15MB., type: Unknown}
    - {contextPath: FD.Ticket.Status, description: Status of the ticket, type: Number}
    - {contextPath: FD.Ticket.RequesterId, description: User ID of the requester,
      type: Number}
    - {contextPath: FD.Ticket.Tags, description: Tags that have been associated with
        the ticket, type: Unknown}
    - {contextPath: FD.Ticket.GroupId, description: ID of the group to which the ticket
        has been assigned, type: Number}
    - {contextPath: FD.Ticket.Source, description: The channel through which the ticket
        was created, type: Number}
    - {contextPath: FD.Ticket.CreatedAt, description: Ticket creation timestamp, type: Date}
    - {contextPath: FD.Ticket.ResponderId, description: ID of the agent to whom the
        ticket has been assigned, type: Number}
    - {contextPath: FD.Ticket.FrDueBy, description: Timestamp that denotes when the
        first response is due, type: Date}
    - {contextPath: FD.Ticket.Id, description: ID number of the ticket, type: Number}
    - {contextPath: FD.Ticket.AdditionalFields, description: Additional fields that
        were entered using the 'additional_fields' and 'additional_values' arguments.,
      type: Unknown}
  - arguments:
    - default: false
      defaultValue: ''
      description: ID number of the ticket to fetch
      isArray: false
      name: id
      predefined: []
      required: true
    - default: false
      defaultValue: ''
      description: If set to 'yes' then the ticket requester's id, email, mobile,
        name, and phone will be included in the ticket's output.
      isArray: false
      name: include_requester
      predefined: ['yes', 'no']
      required: false
    - default: false
      defaultValue: ''
      description: If set to 'yes' then ticketâ€™s closed_at, resolved_at and first_responded_at
        time will be included in the response.
      isArray: false
      name: include_stats
      predefined: ['yes', 'no']
      required: false
    description: View a Ticket.
    execution: false
    name: fd-view-ticket
    outputs:
    - {contextPath: FD.Ticket.Priority, description: Priority of the ticket, type: Number}
    - {contextPath: FD.Ticket.DueBy, description: Timestamp that denotes when the
        ticket is due to be resolved, type: Date}
    - {contextPath: FD.Ticket.Subject, description: Subject of the ticket, type: String}
    - {contextPath: FD.Ticket.Attachments, description: Ticket attachments. The total
        size of these attachments cannot exceed 15MB., type: Unknown}
    - {contextPath: FD.Ticket.Status, description: Status of the ticket, type: Number}
    - {contextPath: FD.Ticket.RequesterId, description: User ID of the requester,
      type: Number}
    - {contextPath: FD.Ticket.Tags, description: Tags that have been associated with
        the ticket, type: Unknown}
    - {contextPath: FD.Ticket.GroupId, description: ID of the group to which the ticket
        has been assigned, type: Number}
    - {contextPath: FD.Ticket.Source, description: The channel through which the ticket
        was created, type: Number}
    - {contextPath: FD.Ticket.CreatedAt, description: Ticket creation timestamp, type: Date}
    - {contextPath: FD.Ticket.ResponderId, description: ID of the agent to whom the
        ticket has been assigned, type: Number}
    - {contextPath: FD.Ticket.FrDueBy, description: Timestamp that denotes when the
        first response is due, type: Date}
    - {contextPath: FD.Ticket.Conversation, description: Conversations associated
        with this ticket, type: Unknown}
    - {contextPath: FD.Ticket.Id, description: ID of the fetched ticket, type: Number}
  - arguments:
    - default: false
      defaultValue: ''
      description: Subject of the ticket. The default Value is null.
      isArray: false
      name: subject
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: Status of the ticket. Each number has a corresponding value. 2
        is Open, 3 is Pending, 4 is Resolved, 5 is Closed, 6 is Waiting on Customer,
        7 is Waiting on Third Party.
      isArray: false
      name: status
      predefined: ['2', Open, '3', Pending, '4', Resolved, '5', Closed, '6', Waiting
          on Customer, '7', Waiting on Third Party]
      required: false
    - default: false
      defaultValue: ''
      description: Priority of the ticket. Each number has a corresponding value.
        1 is Low, 2 is Medium, 3 is High, 4 is Urgent.
      isArray: false
      name: priority
      predefined: ['1', Low, '2', Medium, '3', High, '4', Urgent]
      required: false
    - default: false
      defaultValue: ''
      description: HTML content of the ticket.
      isArray: false
      name: description
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: ID number of the ticket to update
      isArray: false
      name: id
      predefined: []
      required: true
    - default: false
      defaultValue: ''
      description: Update which agent is assigned to respond to this ticket by entering
        either their unique agent ID, name, or email.
      isArray: false
      name: assigned_agent
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: Update the group assigned to respond to this ticket by entering
        the group's unique ID or the name of the group.
      isArray: false
      name: assigned_group
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: List of ticket fields you wish to update the values of.
      isArray: true
      name: update_fields
      predefined: [name, requester_id, email, facebook_id, phone, twitter_id, unique_external_id,
        type, attachments, custom_fields, email_config_id, product_id, source, tags,
        company_id, due_by, fr_due_by]
      required: false
    - default: false
      defaultValue: ''
      description: List of values that are assigned to the field at the same list
        index in the update_fields argument.
      isArray: true
      name: update_values
      predefined: []
      required: false
    description: Update the ticket specified by the ID
    execution: false
    name: fd-update-ticket
    outputs:
    - {contextPath: FD.Ticket.Priority, description: Priority of the ticket, type: Number}
    - {contextPath: FD.Ticket.DueBy, description: Timestamp that denotes when the
        ticket is due to be resolved, type: Date}
    - {contextPath: FD.Ticket.Subject, description: Subject of the ticket, type: String}
    - {contextPath: FD.Ticket.Attachments, description: Ticket attachments. The total
        size of these attachments cannot exceed 15MB., type: Unknown}
    - {contextPath: FD.Ticket.Status, description: Status of the ticket, type: Number}
    - {contextPath: FD.Ticket.RequesterId, description: User ID of the requester,
      type: Number}
    - {contextPath: FD.Ticket.Tags, description: Tags that have been associated with
        the ticket, type: Unknown}
    - {contextPath: FD.Ticket.GroupId, description: ID of the group to which the ticket
        has been assigned, type: Number}
    - {contextPath: FD.Ticket.Source, description: The channel through which the ticket
        was created, type: Number}
    - {contextPath: FD.Ticket.CreatedAt, description: Ticket creation timestamp, type: Date}
    - {contextPath: FD.Ticket.ResponderId, description: ID of the agent to whom the
        ticket has been assigned, type: Number}
    - {contextPath: FD.Ticket.FrDueBy, description: Timestamp that denotes when the
        first response is due, type: Date}
    - {contextPath: FD.Ticket.UpdatedAt, description: Ticket update timestamp, type: Date}
    - {contextPath: FD.Ticket.AdditionalFields, description: Additional fields that
        were updated using the 'update_fields' and 'update_values' arguments., type: Unknown}
    - {contextPath: FD.Ticket.Id, description: ID of the updated ticket, type: Number}
  - arguments:
    - default: false
      defaultValue: ''
      description: mobile number to filter the contacts by
      isArray: false
      name: mobile
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: phone number to filter contacts by
      isArray: false
      name: phone
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: Company ID by which to filter the contacts
      isArray: false
      name: company_id
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: The state of contacts by which you want to filter the contacts
      isArray: false
      name: state
      predefined: [blocked, deleted, unverified, verified]
      required: false
    - default: false
      defaultValue: ''
      description: return contacts that have been updated after the timestamp given
        as this argument value
      isArray: false
      name: updated_since
      predefined: []
      required: false
    description: List all contacts matching the specified filters. If no filters are
      provided then all unblocked and undeleted contacts will be returned.
    execution: false
    name: fd-list-contacts
    outputs:
    - {contextPath: FD.Contact.Active, description: Set to true if the contact has
        been verified, type: Boolean}
    - {contextPath: FD.Contact.Address, description: Address of the contact, type: String}
    - {contextPath: FD.Contact.Avatar, description: Avatar of the contact, type: Unknown}
    - {contextPath: FD.Contact.CompanyId, description: ID of the primary company to
        which this contact belongs, type: Number}
    - {contextPath: FD.Contact.ViewAllTickets, description: Set to true if the contact
        can see all tickets that are associated with the company to which s/he belong,
      type: Boolean}
    - {contextPath: FD.Contact.CustomFields, description: Key value pair containing
        the name and value of the custom fields., type: Unknown}
    - {contextPath: FD.Contact.Deleted, description: Set to true if the contact has
        been deleted., type: Boolean}
    - {contextPath: FD.Contact.Description, description: A short description of the
        contact, type: String}
    - {contextPath: FD.Contact.Email, description: Primary email address of the contact.,
      type: String}
    - {contextPath: FD.Contact.Id, description: ID of the contact, type: Number}
    - {contextPath: FD.Contact.JobTitle, description: Job Title of the contact, type: String}
    - {contextPath: FD.Contact.Language, description: Language of the contact, type: String}
    - {contextPath: FD.Contact.Mobile, description: Mobile number of the contact,
      type: Number}
    - {contextPath: FD.Contact.Name, description: Name of the contact, type: String}
    - {contextPath: FD.Contact.OtherEmails, description: Additional emails associated
        with the contact, type: Unknown}
    - {contextPath: FD.Contact.Phone, description: Telephone number of the contact,
      type: Number}
    - {contextPath: FD.Contact.Tags, description: Tags associated with this contact,
      type: Unknown}
    - {contextPath: FD.Contact.TimeZone, description: Time zone in which the contact
        resides, type: String}
    - {contextPath: FD.Contact.TwitterId, description: Twitter handle of the contact,
      type: String}
    - {contextPath: FD.Contact.UniqueExternalId, description: External ID of the contact,
      type: String}
    - {contextPath: FD.Contact.OtherCompanies, description: Additional companies associated
        with the contact (array of hashes), type: Unknown}
    - {contextPath: FD.Contact.CreatedAt, description: Contact creation stamp, type: Date}
    - {contextPath: FD.Contact.UpdatedAt, description: Contact updated timestamp,
      type: Date}
  - arguments:
    - default: false
      defaultValue: ''
      description: ID of the contact you wish to view the details of
      isArray: false
      name: id
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: Mobile number of the contact you wish to view the details of
      isArray: false
      name: mobile
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: Email address of the contact you wish to view the details of
      isArray: false
      name: email
      predefined: []
      required: false
    description: View the details of the contact specified by the ID number
    execution: false
    name: fd-view-contact
    outputs:
    - {contextPath: FD.Contact.Active, description: Set to true if the contact has
        been verified, type: Boolean}
    - {contextPath: FD.Contact.Address, description: Address of the contact, type: String}
    - {contextPath: FD.Contact.Avatar, description: Avatar of the contact, type: Unknown}
    - {contextPath: FD.Contact.CompanyId, description: ID of the primary company to
        which this contact belongs, type: Number}
    - {contextPath: FD.Contact.ViewAllTickets, description: Set to true if the contact
        can see all tickets that are associated with the company to which s/he belong,
      type: Boolean}
    - {contextPath: FD.Contact.CustomFields, description: Key value pair containing
        the name and value of the custom fields., type: Unknown}
    - {contextPath: FD.Contact.Deleted, description: Set to true if the contact has
        been deleted., type: Boolean}
    - {contextPath: FD.Contact.Description, description: A short description of the
        contact, type: String}
    - {contextPath: FD.Contact.Email, description: Primary email address of the contact.,
      type: String}
    - {contextPath: FD.Contact.Id, description: ID of the contact, type: Number}
    - {contextPath: FD.Contact.JobTitle, description: Job Title of the contact, type: String}
    - {contextPath: FD.Contact.Language, description: Language of the contact, type: String}
    - {contextPath: FD.Contact.Mobile, description: Mobile number of the contact,
      type: Number}
    - {contextPath: FD.Contact.Name, description: Name of the contact, type: String}
    - {contextPath: FD.Contact.OtherEmails, description: Additional emails associated
        with the contact, type: Unknown}
    - {contextPath: FD.Contact.Phone, description: Telephone number of the contact,
      type: Number}
    - {contextPath: FD.Contact.Tags, description: Tags associated with this contact,
      type: Unknown}
    - {contextPath: FD.Contact.TimeZone, description: Time zone in which the contact
        resides, type: String}
    - {contextPath: FD.Contact.TwitterId, description: Twitter handle of the contact,
      type: String}
    - {contextPath: FD.Contact.UniqueExternalId, description: External ID of the contact,
      type: String}
    - {contextPath: FD.Contact.OtherCompanies, description: Additional companies associated
        with the contact (array of hashes), type: Unknown}
    - {contextPath: FD.Contact.CreatedAt, description: Contact creation stamp, type: Date}
    - {contextPath: FD.Contact.UpdatedAt, description: Contact updated timestamp,
      type: Date}
  - arguments: []
    description: List all Canned Response Folders (Only users with Admin Privileges)
    execution: false
    name: fd-list-cr-folders
    outputs:
    - {contextPath: FD.CRFolder.Id, description: Unique ID of the canned response
        folder, type: Number}
    - {contextPath: FD.CRFolder.Name, description: Name of the canned response folder,
      type: String}
    - {contextPath: FD.CRFolder.Personal, description: Set true if the folder can
        only be accessed by you, type: Boolean}
    - {contextPath: FD.CRFolder.ResponsesCount, description: Number of canned responses
        in the folder, type: Number}
    - {contextPath: FD.CRFolder.CreatedAt, description: Canned Response Folder's creation
        timestamp, type: Date}
    - {contextPath: FD.CRFolder.UpdatedAt, description: Canned Response Folder's updated
        timestamp, type: Date}
  - arguments:
    - default: false
      defaultValue: ''
      description: ID of the Canned Response folder for which you want to list the
        canned responses inside of it. To find the ID of a Canned Response folder,
        execute the `fd-list-cr-folders` command to see the Canned Response folders
        accessible to you.
      isArray: false
      name: id
      predefined: []
      required: true
    description: List all Canned Responses in a Folder
    execution: false
    name: fd-list-crs-in-folder
    outputs:
    - {contextPath: FD.CRFolder.CR.Id, description: ID of the Canned Response, type: Number}
    - {contextPath: FD.CRFolder.CR.Title, description: Title of the Canned Response,
      type: String}
  - arguments:
    - default: false
      defaultValue: ''
      description: ID of the Folder containing the Canned Responses you wish to view
        the details of
      isArray: false
      name: id
      predefined: []
      required: true
    description: View the details of all the Canned Responses in a Folder.
    execution: false
    name: fd-detail-crs
    outputs:
    - {contextPath: FD.CRFolder.CR.Id, description: Unique ID of the canned response,
      type: Number}
    - {contextPath: FD.CRFolder.CR.Title, description: Title of the canned response,
      type: String}
    - {contextPath: FD.CRFolder.CR.FolderId, description: ID of the containing folder,
      type: Number}
    - {contextPath: FD.CRFolder.CR.Content, description: Plaintext version of the
        canned response content, type: String}
    - {contextPath: FD.CRFolder.CR.ContentHtml, description: HTML version of the canned
        response content, type: String}
    - {contextPath: FD.CRFolder.CR.Attachments, description: Array of attachments
        associated with the canned response, type: Unknown}
  - arguments: []
    description: List all groups
    execution: false
    name: fd-list-groups
    outputs:
    - {contextPath: FD.Group.AgentIds, description: Array of agent user IDs separated
        by commas., type: Unknown}
    - {contextPath: FD.Group.AutoTicketAssign, description: Set to true if automatic
        ticket assignment has been enabled. Automatic ticket assignment is only available
        on certain plans., type: Boolean}
    - {contextPath: FD.Group.BusinessHourId, description: Unique ID of the business
        hour associated with the group, type: Number}
    - {contextPath: FD.Group.Description, description: Description of the group, type: String}
    - {contextPath: FD.Group.EscalateTo, description: The ID of the user to whom an
        escalation email is sent if a ticket is unassigned., type: Number}
    - {contextPath: FD.Group.Id, description: Unique ID of the group, type: Number}
    - {contextPath: FD.Group.Name, description: Name of the group, type: String}
    - {contextPath: FD.Group.UnassignedFor, description: 'The time after which an
        escalation email is sent if a ticket remains unassigned. The accepted values
        are "30m" for 30 minutes, "1h" for 1 hour, "2h" for 2 hours, "4h" for 4 hours,
        "8h" for 8 hours, "12h" for 12 hours, "1d" for 1 day, "2d" for 2 days, and
        "3d" for 3 days', type: String}
    - {contextPath: FD.Group.CreatedAt, description: Group creation timestamp, type: Date}
    - {contextPath: FD.Group.UpdatedAt, description: Grup updated timestamp, type: Date}
    - {contextPath: FD.Group.GroupType, description: Group Type of the group, type: String}
  - arguments:
    - default: false
      defaultValue: ''
      description: ID of the ticket you wish to respond to
      isArray: false
      name: ticket_id
      predefined: []
      required: true
    - default: false
      defaultValue: ''
      description: Content of the reply in HTML format
      isArray: false
      name: body
      predefined: []
      required: true
    - default: false
      defaultValue: ''
      description: The email address from which the reply is sent. By default the
        global support email will be used.
      isArray: false
      name: from_email
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: ID of the agent who is adding the note
      isArray: false
      name: user_id
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: Array of email address strings added in the 'cc' field of the outgoing
        ticket email.
      isArray: true
      name: cc_emails
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: Array of email address strings added in the 'bcc' field of the
        outgoing ticket email.
      isArray: true
      name: bcc_emails
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: Entry IDs of files to attach to the reply. The total size of these
        attachments cannot exceed 15MB.
      isArray: true
      name: attachments
      predefined: []
      required: false
    description: Reply to a specified ticket
    execution: false
    name: fd-ticket-reply
    outputs:
    - {contextPath: FD.Ticket.Conversation.Attachments, description: Array of attachments
        associated with the conversation., type: Unknown}
    - {contextPath: FD.Ticket.Conversation.Body, description: Content of the conversation
        in HTML, type: String}
    - {contextPath: FD.Ticket.Conversation.BodyText, description: Content of the conversation
        in plain text, type: String}
    - {contextPath: FD.Ticket.Conversation.Id, description: ID of the conversation,
      type: Number}
    - {contextPath: FD.Ticket.Conversation.Incoming, description: 'Set to true if
        a particular conversation should appear as being created from outside (i.e.,
        not through web portal)', type: Boolean}
    - {contextPath: FD.Ticket.Conversation.ToEmails, description: Array of email addresses
        of agents/users who need to be notified about this conversation, type: Unknown}
    - {contextPath: FD.Ticket.Conversation.Private, description: Set to true if the
        note is private, type: Boolean}
    - {contextPath: FD.Ticket.Conversation.Source, description: Denotes the type of
        conversation, type: Number}
    - {contextPath: FD.Ticket.Conversation.SupportEmail, description: 'Email address
        from which the reply is sent. For notes, this value will be null.', type: String}
    - {contextPath: FD.Ticket.Conversation.TicketId, description: ID of the ticket
        to which this conversation is being added, type: Number}
    - {contextPath: FD.Ticket.Conversation.UserId, description: ID of the agent/user
        who is adding the conversation, type: Number}
    - {contextPath: FD.Ticket.Conversation.CreatedAt, description: Conversation creation
        timestamp, type: Date}
    - {contextPath: FD.Ticket.Conversation.UpdatedAt, description: Conversation updated
        timestamp, type: Date}
    - {contextPath: FD.Ticket.Conversation.FromEmail, description: The email address
        from which the reply is sent. By default the global support email will be
        used., type: String}
  - arguments:
    - default: false
      defaultValue: ''
      description: ID of the ticket for which you would like to list all of its conversations
      isArray: false
      name: ticket_id
      predefined: []
      required: true
    description: ''
    execution: false
    name: fd-get-conversations
    outputs:
    - {contextPath: FD.Ticket.Conversation.Attachments, description: Array of attachments
        associated with the conversation., type: Unknown}
    - {contextPath: FD.Ticket.Conversation.Body, description: Content of the conversation
        in HTML, type: String}
    - {contextPath: FD.Ticket.Conversation.BodyText, description: Content of the conversation
        in plain text, type: String}
    - {contextPath: FD.Ticket.Conversation.Id, description: ID of the conversation,
      type: Number}
    - {contextPath: FD.Ticket.Conversation.Incoming, description: 'Set to true if
        a particular conversation should appear as being created from outside (i.e.,
        not through web portal)', type: Boolean}
    - {contextPath: FD.Ticket.Conversation.ToEmails, description: Array of email addresses
        of agents/users who need to be notified about this conversation, type: Unknown}
    - {contextPath: FD.Ticket.Conversation.Private, description: Set to true if the
        note is private, type: Boolean}
    - {contextPath: FD.Ticket.Conversation.Source, description: Denotes the type of
        conversation, type: Number}
    - {contextPath: FD.Ticket.Conversation.SupportEmail, description: 'Email address
        from which the reply is sent. For notes, this value will be null.', type: String}
    - {contextPath: FD.Ticket.Conversation.TicketId, description: ID of the ticket
        to which this note or reply belongs, type: Number}
    - {contextPath: FD.Ticket.Conversation.UserId, description: ID of the agent/user
        who is adding the conversation, type: Number}
    - {contextPath: FD.Ticket.Conversation.CreatedAt, description: Conversation creation
        timestamp, type: Date}
    - {contextPath: FD.Ticket.Conversation.UpdatedAt, description: Conversation updated
        timestamp, type: Date}
    - {contextPath: FD.Ticket.Conversation.FromEmail, description: The email address
        from which the reply/note is sent. By default the global support email will
        be used., type: String}
  - arguments:
    - default: false
      defaultValue: ''
      description: mobile phone number to filter agents by
      isArray: false
      name: mobile
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: telephone number to filter agents by
      isArray: false
      name: phone
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: list all agents who are either 'fulltime' or 'occasional'
      isArray: false
      name: state
      predefined: [fulltime, occasional]
      required: false
    description: List agents that match the criteria of the filters entered as command
      arguments.
    execution: false
    name: fd-list-agents
    outputs:
    - {contextPath: FD.Agent.Available, description: 'If the agent is in a group that
        has enabled "Automatic Ticket Assignment", this attribute will be set to true
        if the agent is accepting new tickets', type: Boolean}
    - {contextPath: FD.Agent.AvailableSince, description: Timestamp that denotes when
        the agent became available/unavailable (depending on the value of the 'available'
        attribute), type: Date}
    - {contextPath: FD.Agent.Id, description: User ID of the agent, type: Number}
    - {contextPath: FD.Agent.Occasional, description: 'Set to true if this is an occasional
        agent (true => occasional, false => full-time)', type: Boolean}
    - {contextPath: FD.Agent.Signature, description: Signature of the agent in HTML
        format, type: String}
    - contextPath: FD.Agent.TicketScope
      description: |-
        Ticket permission of the agent
        (1 -> Global Access, 2 -> Group Access, 3 -> Restricted Access)
      type: Number
    - {contextPath: FD.Agent.GroupIds, description: Group IDs associated with the
        agent, type: Unknown}
    - {contextPath: FD.Agent.RoleIds, description: Role IDs associated with the agent,
      type: Unknown}
    - {contextPath: FD.Agent.CreatedAt, description: Agent creation timestamp, type: Date}
    - {contextPath: FD.Agent.UpdatedAt, description: Agent updated timestamp, type: Date}
    - {contextPath: FD.Agent.Contact.Active, description: Set to true if the agent
        is verified, type: Boolean}
    - {contextPath: FD.Agent.Contact.Email, description: Email Address of the agent,
      type: String}
    - {contextPath: FD.Agent.Contact.JobTitle, description: Job title of the agent,
      type: String}
    - {contextPath: FD.Agent.Contact.Language, description: Language of the agent.
        Default language is "en", type: String}
    - {contextPath: FD.Agent.Contact.LastLoginAt, description: Timestamp of the agent's
        last successful login, type: Date}
    - {contextPath: FD.Agent.Contact.Mobile, description: Mobile number of the agent,
      type: Number}
    - {contextPath: FD.Agent.Contact.Name, description: Name of the agent, type: String}
    - {contextPath: FD.Agent.Contact.Phone, description: Telephone number of the agent,
      type: Number}
    - {contextPath: FD.Agent.Contact.TimeZone, description: Time zone of the agent,
      type: String}
    - {contextPath: FD.Agent.Contact.CreatedAt, description: Creation timestamp, type: Date}
    - {contextPath: FD.Agent.Contact.UpdatedAt, description: Timestamp of the last
        update, type: Date}
    - {contextPath: FD.Agent.Type, description: Type of agent, type: String}
  - arguments:
    - default: false
      defaultValue: ''
      description: ID of the ticket you wish to make a note for
      isArray: false
      name: ticket_id
      predefined: []
      required: true
    - default: false
      defaultValue: ''
      description: Content of the note in HTML format
      isArray: false
      name: body
      predefined: []
      required: true
    - default: false
      defaultValue: ''
      description: Set to false if the note is not private
      isArray: false
      name: private
      predefined: ['True', 'False']
      required: false
    - default: false
      defaultValue: ''
      description: ID of the agent who is adding the note
      isArray: false
      name: user_id
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: Array of email addresses of agents/users who need to be notified
        about this note
      isArray: true
      name: notify_emails
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: Set to true if a particular note should appear as being created
        from outside (i.e., not through web portal).
      isArray: false
      name: incoming
      predefined: ['True', 'False']
      required: false
    - default: false
      defaultValue: ''
      description: Entry IDs of files to attach to the note. The total size of these
        attachments cannot exceed 15MB.
      isArray: true
      name: attachments
      predefined: []
      required: false
    description: Create a note for a specified ticket. By default any note you add
      will be private unless you set the 'private' command argument to False.
    execution: false
    name: fd-ticket-note
    outputs:
    - {contextPath: FD.Ticket.Conversation.Attachments, description: Array of attachments
        associated with the conversation., type: Unknown}
    - {contextPath: FD.Ticket.Conversation.Body, description: Content of the conversation
        in HTML, type: String}
    - {contextPath: FD.Ticket.Conversation.BodyText, description: Content of the conversation
        in plain text, type: String}
    - {contextPath: FD.Ticket.Conversation.Id, description: ID of the conversation,
      type: Number}
    - {contextPath: FD.Ticket.Conversation.Incoming, description: 'Set to true if
        a particular conversation should appear as being created from outside (i.e.,
        not through web portal)', type: Boolean}
    - {contextPath: FD.Ticket.Conversation.ToEmails, description: Array of email addresses
        of agents/users who need to be notified about this conversation, type: Unknown}
    - {contextPath: FD.Ticket.Conversation.Private, description: Set to true if the
        note is private, type: Boolean}
    - {contextPath: FD.Ticket.Conversation.Source, description: Denotes the type of
        conversation, type: Number}
    - {contextPath: FD.Ticket.Conversation.SupportEmail, description: 'Email address
        from which the reply is sent. For notes, this value will be null.', type: String}
    - {contextPath: FD.Ticket.Conversation.TicketId, description: ID of the ticket
        to which this conversation is being added, type: Number}
    - {contextPath: FD.Ticket.Conversation.UserId, description: ID of the agent/user
        who is adding the conversation, type: Number}
    - {contextPath: FD.Ticket.Conversation.CreatedAt, description: Conversation creation
        timestamp, type: Date}
    - {contextPath: FD.Ticket.Conversation.UpdatedAt, description: Conversation updated
        timestamp, type: Date}
    - {contextPath: FD.Ticket.Conversation.FromEmail, description: The email address
        from which the reply/note is sent. By default the global support email will
        be used., type: String}
  - arguments:
    - default: false
      defaultValue: ''
      description: ID of the ticket to delete
      isArray: false
      name: id
      predefined: []
      required: true
    description: Delete the ticket specified by the 'id' command argument
    execution: false
    name: fd-delete-ticket
    outputs: []
  - arguments:
    - default: false
      defaultValue: ''
      description: Predefined filters
      isArray: false
      name: filter
      predefined: [new_and_my_open, watching, spam, deleted]
      required: false
    - default: false
      defaultValue: ''
      description: Filter by either the ticket requester's email or ID
      isArray: false
      name: requester
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: Filter by tickets associated with the specified company ID
      isArray: false
      name: company_id
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: By default, only tickets that have been created within the past
        30 days will be returned. For older tickets, use this filter. Example value
        for this field would be "2015-01-19T02:00:00Z"
      isArray: false
      name: updated_since
      predefined: []
      required: false
    - default: false
      defaultValue: ''
      description: Reference field for ordering the list of tickets. The default sort
        order is created_at.
      isArray: false
      name: order_by
      predefined: [created_at, due_by, updated_at, status]
      required: false
    - default: false
      defaultValue: ''
      description: Whether to order the resulting tickets in ascending or descending
        order. The default is descending.
      isArray: false
      name: order_type
      predefined: [asc, desc]
      required: false
    - default: false
      defaultValue: ''
      description: If set to 'yes' then ticketâ€™s closed_at, resolved_at and first_responded_at
        time will be included.
      isArray: false
      name: include_stats
      predefined: ['yes', 'no']
      required: false
    - default: false
      defaultValue: ''
      description: If set to 'yes' then the ticket requester's id, email, mobile,
        name, and phone will be included in the ticket's output for each ticket.
      isArray: false
      name: include_requester
      predefined: ['yes', 'no']
      required: false
    - default: false
      defaultValue: ''
      description: If set to 'yes' then the ticket's description and description_text
        will be included the tickets' outputs.
      isArray: false
      name: include_description
      predefined: ['yes', 'no']
      required: false
    - default: false
      defaultValue: ''
      description: |-
        Filter tickets using a custom query.

        Format -    "(ticket_field:integer OR ticket_field:'string') AND ticket_field:boolean"
        Example -  "(type:'Question' OR type:'Problem') AND (due_by:>'2017-10-01' AND due_by:<'2017-10-07')"

        Note that the custom_query argument cannot be used in conjunction with this command's other arguments.
      isArray: false
      name: custom_query
      predefined: []
      required: false
    description: List all tickets that match the filter criteria you specify.
    execution: false
    name: fd-list-tickets
    outputs:
    - {contextPath: FD.Ticket.Priority, description: Priority of the ticket, type: Number}
    - {contextPath: FD.Ticket.DueBy, description: Timestamp that denotes when the
        ticket is due to be resolved, type: Date}
    - {contextPath: FD.Ticket.Subject, description: Subject of the ticket, type: String}
    - {contextPath: FD.Ticket.Attachments, description: Ticket attachments. The total
        size of these attachments cannot exceed 15MB., type: Unknown}
    - {contextPath: FD.Ticket.Status, description: Status of the ticket, type: Number}
    - {contextPath: FD.Ticket.RequesterId, description: User ID of the requester,
      type: Number}
    - {contextPath: FD.Ticket.Tags, description: Tags that have been associated with
        the ticket, type: Unknown}
    - {contextPath: FD.Ticket.GroupId, description: ID of the group to which the ticket
        has been assigned, type: Number}
    - {contextPath: FD.Ticket.Source, description: The channel through which the ticket
        was created, type: Number}
    - {contextPath: FD.Ticket.CreatedAt, description: Ticket creation timestamp, type: Date}
    - {contextPath: FD.Ticket.ResponderId, description: ID of the agent to whom the
        ticket has been assigned, type: Number}
    - {contextPath: FD.Ticket.FrDueBy, description: Timestamp that denotes when the
        first response is due, type: Date}
    - {contextPath: FD.Ticket.UpdatedAt, description: Ticket update timestamp, type: Date}
    - {contextPath: FD.Ticket.AdditionalFields, description: Additional fields that
        were specified in the command's filter-type or include-type arguments., type: Unknown}
    - {contextPath: FD.Ticket.Id, description: ID of the updated ticket, type: Number}
  dockerimage: ''
  isfetch: true
  runonce: false
  script: |-
    ''' IMPORTS '''

    # For debugging
    import sys, traceback

    import json
    import requests
    from datetime import datetime
    from distutils.util import strtobool

    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    ''' GLOBALS/PARAMS '''

    CREDS = demisto.params().get('credentials')
    USERNAME = CREDS.get('identifier') if CREDS else None
    PASSWORD = CREDS.get('password') if CREDS else None
    TOKEN = demisto.params().get('token')

    if not (USERNAME and PASSWORD) and not TOKEN:
        err_msg = "You must provide either your freshdesk account API key or the " \
                  "username and password you use to sign into your freshdesk account " \
                  "when instantiating an instance of the freshdesk integration."
        return_error(err_msg)

    AUTH = (TOKEN, 'X') if TOKEN else (USERNAME, PASSWORD)

    # How many time before the first fetch to retrieve incidents
    FETCH_TIME = demisto.params().get('fetch_time', '3 days')

    # Remove trailing slash to prevent wrong URL path to service
    SERVER = demisto.params()['url'][:-1] if (demisto.params()['url'] and demisto.params()['url'].endswith('/')) else demisto.params()['url']
    # Should we use SSL
    USE_SSL = not demisto.params().get('unsecure', False)
    # Service base URL
    BASE_URL = SERVER + '/api/v2/'
    # Headers to be sent in requests
    HEADERS = {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    }

    PER_PAGE = 30

    DEFAULT_TICKET_CONTEXT_FIELDS = [
        'priority', 'due_by', 'subject', 'attachments', 'status',
        'requester_id', 'tags', 'group_id', 'source', 'created_at',
        'responder_id', 'fr_due_by', 'id'
    ]

    # Remove proxy if not set to true in params
    if not demisto.params().get('proxy'):
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']


    ''' HELPER FUNCTIONS '''


    def handle_list_tickets_pagination(args, response):
        # If user entered custom_query arg, the resulting tickets are in the 'results' attribute of the response
        max_pages = 10
        if args.get('custom_query'):
            # Deal with pagination if necessary
            tickets = response.get('results')
            total_tickets = response.get('total')
            total_tickets -= PER_PAGE
            page = 1
            while total_tickets > 0 and page <= max_pages:
                page += 1
                args['page'] = page
                tickets_page = list_tickets(args)
                tickets.extend(tickets_page.get('results'))
                total_tickets -= PER_PAGE
        else:
            tickets = response
            page = 1
            next_page = tickets
            while next_page and page <= max_pages:
                page += 1
                args['page'] = page
                next_page = list_tickets(args)
                if next_page:
                    tickets.extend(next_page)
        return tickets


    def attachments_into_context(api_response, context):
        # Parse attachments into context
        attachments = api_response.get('attachments')
        if attachments:
            attachments_context = []
            for attachment in attachments:
                attachment_context = {string_to_context_key(key): val for key, val in attachment.iteritems()}
                attachments_context.append(attachment_context)
            context['Attachments'] = attachments_context
        return context


    def additional_fields_to_context(context, already_in_context, additional_fields, additional_values):
        # Parse additional fields into context
        if additional_fields and additional_values:
            additional_field_contexts = []
            for field, value in zip(additional_fields, additional_values):
                if field not in already_in_context:
                    field_context = {string_to_context_key(field): value}
                    additional_field_contexts.append(field_context)
            context['AdditionalFields'] = additional_field_contexts
        return context


    def reformat_args(args, fields_arg_name, values_arg_name):
        # Format args according to API expecations
        additional_update_fields = args.get(fields_arg_name)
        additional_field_values = args.get(values_arg_name)
        if additional_update_fields and additional_field_values:
            for field, value in zip(additional_update_fields, additional_field_values):
                args[field] = value
            del args[fields_arg_name]
            del args[values_arg_name]
        return args


    def addional_fields_to_args(args, fields_arg_name, values_arg_name):
        fields_arg = args.get(fields_arg_name)
        values_arg = args.get(values_arg_name)
        if fields_arg and values_arg:
            additional_fields = argToList(fields_arg)
            # Doesn't use argToList because does not split properly for our purposes
            additional_fields_values = values_arg.split(',')

            demisto.log('args: {}'.format(args))

            # Handle sublists in command line arg of 'update_values'
            in_sublist = False
            tmp_list = []
            sublist = []
            for i, val in enumerate(additional_fields_values):
                if val.find('[') != -1:
                    in_sublist = True
                    sublist.append(val[val.find('[') + 1:])
                    demisto.log('inloop, opening bracket found\ninloop sublist: {}'.format(sublist) + '\ninloop tmp_list: {}'.format(tmp_list))
                elif val.find(']') != -1:
                    sublist.append(val[:val.find(']') - len(val)])
                    tmp_list.append(sublist[:])
                    demisto.log('inloop, endbracket found\ninloop sublist: {}'.format(sublist) + '\ninloop tmp_list: {}'.format(tmp_list))
                    del sublist[:]
                    in_sublist = False
                elif in_sublist:
                    sublist.append(val)
                    demisto.log('inloop, in_sublist is true\ninloop sublist: {}'.format(sublist) + '\ninloop tmp_list: {}'.format(tmp_list))
                else:
                    tmp_list.append(val)
                    demisto.log('inloop, not in_sublist\ninloop sublist: {}'.format(sublist) + '\ninloop tmp_list: {}'.format(tmp_list))
            additional_fields_values = tmp_list
            args[values_arg_name] = additional_fields_values
            args[fields_arg_name] = additional_fields

            if len(additional_fields) != len(additional_fields_values):
                err_msg = "The '{}' list and '{}' list command arguments".format(fields_arg_name, values_arg_name)
                err_msg += " must contain the same number of items."
                err_msg += "\nlength of '{}' list: {}".format(fields_arg_name, len(additional_fields))
                err_msg += "\nlength of '{}' list: {}".format(values_arg_name, len(additional_fields_values))
                return_error(err_msg)
            return args, additional_fields, additional_fields_values
        else:
            return args, None, None


    def ticket_to_incident(ticket):
        incident = {}
        # Incident Title
        incident['name'] = 'Ticket Incident: "{}"'.format(ticket.get('subject'))
        # Incident occurrence time, usually item creation date in service
        incident['occurred'] = ticket.get('created_at')
        # The raw response from the service, providing full info regarding the item
        incident['rawJSON'] = json.dumps(ticket)
        return incident


    def get_additional_fields(args):
        additional_fields = []  # fields that should be added to output context
        filter = args.get('filter')
        if filter:
            if filter == 'deleted':
                additional_fields.append('deleted')
            elif filter == 'spam':
                additional_fields.append('spam')
        requester = args.get('requester')
        if requester:
            if '@' in requester:
                additional_fields.append('email')
        company_id = args.get('company_id')
        if company_id:
            additional_fields.append('company_id')
        if args.get('include_description') and args.get('include_description').lower() == 'yes':
            additional_fields.extend(['description', 'description_text'])
        return additional_fields


    def entries_to_files(entry_ids):
        attachments = []
        for entry_id in entry_ids:
            execute_results = demisto.getFilePath(entry_id)
            file_path = execute_results["path"]
            file_name = execute_results["name"]
            attachments.append(('attachments[]', (file_name, open(file_path, 'rb'))))

        return attachments


    def handle_array_input(args):
        array_inputs = [
            'tags', 'attachments', 'cc_emails', 'bcc_emails', 'to_emails',
            'update_fields', 'update_values', 'notify_emails'
        ]

        # demisto.log('args prehandle arrays: {}'.format(args))
        for arr_input in array_inputs:
            if arr_input in args.keys():
                # demisto.log('making arg {} to list\narg {} preadjustment: {}'.format(arr_input, arr_input, args.get(arr_input)))
                if arr_input != 'attachments':
                    args[arr_input + '[]'] = argToList(args.get(arr_input))
                    del args[arr_input]
                else:
                    args[arr_input] = argToList(args.get(arr_input))
                # args[arr_input] = args.get(arr_input).split(',')
                # demisto.log('arg {} postadjustment: {}'.format(arr_input, args.get(arr_input)))
        # demisto.log('args posthandle arrays: {}'.format(args))
        return args


    def handle_bool_input(args):
        bool_inputs = ['private', 'incoming']
        acceptable_vals = ['true', 'false']

        try:
            for bool_input in bool_inputs:
                if bool_input in args.keys():
                    args[bool_input] = args.get(bool_input).lower()
                    if args[bool_input] not in acceptable_vals:
                        raise ValueError('field: "{}"\n'.format(bool_input))
        except ValueError as e:
            return_error(e.message + 'The only valid inputs for this field are either "True" or "False"')

        return args


    def validate_priority_input(args):
        # Parse and ensure valid command argument
        priority = args.get('priority', None)

        # If priority wasn't given by the user as a cmd arg
        # then no need to alter it to API expectations
        if not priority:
            return args

        priorities = ['low', 'medium', 'high', 'urgent']

        # Check if the user entered status as words - aka the
        # options listed above in 'statuses'
        err_msg = "priority should be one of these values: 1, 2, 3, 4, {}".format(', '.join(priorities))
        if len(priority) > 1:
            if priority.lower() in priorities:
                # Add 1 since API status numbers for tickets start at 1
                # Cast to string so clean_arguments helper function doesn't throw any errors
                args['priority'] = str(priorities.index(priority.lower()) + 1)
            else:
                return_error(err_msg)
        # Otherwise make sure the user entered valid status number
        elif not (0 < int(priority) < 5):
            return_error(err_msg)
        return args


    def validate_status_input(args):
        # Parse and ensure valid command argument
        status = args.get('status', None)

        # If status wasn't given by the user as a cmd arg
        # then no need to alter it to API expectations
        if not status:
            return args

        statuses = [
            'open', 'pending', 'resolved', 'closed',
            'waiting on customer', 'waiting on third party'
        ]

        # Check if the user entered status as words - aka the
        # options listed above in 'statuses'
        err_msg = "status should be one of these values: 2, 3, 4, 5, 6, 7, {}".format(', '.join(statuses))
        if len(status) > 1:
            if status.lower() in statuses:
                # Add 2 since API status numbers for tickets start at 2
                # Cast to string so clean_arguments helper function doesn't throw any errors
                args['status'] = str(statuses.index(status.lower()) + 2)
            else:
                return_error(err_msg)
        # Otherwise make sure the user entered valid status number
        elif not (1 < int(status) < 8):
            return_error(err_msg)
        return args


    def clean_arguments(args):
        args = validate_status_input(args)
        args = validate_priority_input(args)
        args = handle_array_input(args)

        # Command args that should be numbers
        number_args = [
            'requester_id', 'status', 'priority', 'responder_id',
            'email_config_id', 'group_id', 'product_id', 'source', 'company_id'
        ]
        # Convert cmd args that are expected to be numbers from strings to numbers
        for num_arg in number_args:
            if num_arg in args.keys():
                args[num_arg] = int(args.get(num_arg))
        return args


    def determine_identifier(args):
        identifier = args.get('identifier')
        if identifier.startswith('@'):
            # Then it's a twitter handle
            args['twitter_id'] = identifier
        else:
            # Otherwise assume it's an email address
            args['email'] = identifier
        # Delete identifier field from args since it doesn't match API expected inputs
        del args['identifier']
        return args


    def determine_responder(args):
        responder = args.get('responder', None)
        if responder:
            args = determine_group(args, 'responder')
            args = determine_agent(args, 'responder')
        return args


    def determine_agent(args, key_name):
        assigned_agent = args.get(key_name, None)
        if assigned_agent:
            agent_emails, agent_names, agent_ids = [], [], []
            # Get names, emails and ids of agents
            agents = list_agents({})
            for agent in agents:
                agent_ids.append(agent.get('id'))
                agent_names.append(agent.get('contact').get('name').lower())
                agent_emails.append(agent.get('contact').get('email').lower())
            # Check if responder value is a contact ID
            if assigned_agent in agent_ids:
                args['responder_id'] = assigned_agent
                # Delete assigned_agent field from args since it doesn't match API expected inputs
                del args[key_name]
            elif assigned_agent.lower() in agent_names:
                args['responder_id'] = agent_ids[agent_names.index(assigned_agent.lower())]
                del args[key_name]
            elif assigned_agent.lower() in agent_emails:
                args['responder_id'] = agent_ids[agent_emails.index(assigned_agent.lower())]
                del args[key_name]

        return args


    def determine_group(args, key_name):
        assigned_group = args.get(key_name, None)
        if assigned_group:
            group_names, group_ids = [], []
            # Get names and ids of groups
            groups = list_groups()
            for group in groups:
                group_ids.append(group.get('id'))
                group_names.append(group.get('name').lower())
            # Check if responder value is a group ID
            if assigned_group in group_ids:
                args['group_id'] = assigned_group
                del args[key_name]
            # Or the name of a group
            elif assigned_group.lower() in group_names:
                args['group_id'] = group_ids[group_names.index(assigned_group.lower())]
                del args[key_name]
        return args


    def http_request(method, url_suffix, params=None, data=None, files=None,):
        # A wrapper for requests lib to send our requests and handle requests and responses better
        res = requests.request(
            method,
            BASE_URL + url_suffix,
            verify=USE_SSL,
            params=params,
            data=data,
            headers=HEADERS,
            auth=AUTH,
            files=files,
        )
        # Handle error responses gracefully
        try:
            if res.status_code not in [200, 201, 202, 204]:
                LOG(res.json())
                LOG(res.text)
                LOG.print_log()
                err_msg = 'Error in API call to Freshdesk Integration [{}] - {}'.format(res.status_code, res.reason)
                err = json.loads(res.content)
                if err.get('errors'):
                    for error in err.get('errors'):
                        err_msg += '\n' + json.dumps(error, indent=2)
                else:
                    for key, value in res.json().iteritems():
                        err_msg += '\n{}: {}'.format(key, value)
                return_error(err_msg)
            # Handle response with no content
            elif res.status_code == 204:
                return res

            return res.json()
        except Exception as e:
            LOG(e)
            ex_type, ex, tb = sys.exc_info()
            traceback.print_tb(tb)
            return_error('error occurred in the http_request method')


    ''' COMMANDS + REQUESTS FUNCTIONS '''


    def test_module():
        """
        Performs basic get request to get item samples
        """
        ticket_id = '1'
        response = http_request('GET', 'tickets/{}'.format(ticket_id))


    def fetch_incidents():
        # demisto.getLastRun() will returns an obj with the previous run in it.
        last_run = demisto.getLastRun()
        # Get the last fetch time, if exists
        last_fetch = last_run.get('time')

        # Handle first time fetch, fetch incidents retroactively
        if not last_fetch:
            last_fetch, _ = parse_date_range(FETCH_TIME, to_timestamp=True)
        # query_string = 'created_at:>\'' + timestamp_to_datestring(last_fetch, date_format="%Y-%m-%d") + '\''
        # args = {'custom_query': query_string}
        updated_since = timestamp_to_datestring(last_fetch, date_format="%Y-%m-%dT%H:%M:%SZ")
        args = {'updated_since': updated_since, 'order_type': 'asc'}

        tickets = list_tickets(args)
        # tickets = response.get('results')
        # convert the ticket/events to demisto incidents
        incidents = []
        for ticket in tickets:
            incident = ticket_to_incident(ticket)
            incident_date = date_to_timestamp(incident['occurred'], '%Y-%m-%dT%H:%M:%SZ')
            # Update last run and add incident if the incident is newer than last fetch
            if incident_date > last_fetch:
                last_fetch = incident_date
                incidents.append(incident)

        demisto.setLastRun({'time': last_fetch})
        demisto.incidents(incidents)


    '''<------ TICKETS ------>'''


    def create_ticket(args):
        args = determine_identifier(args)
        args = determine_responder(args)
        args = reformat_args(args, 'additional_fields', 'additional_values')
        args = clean_arguments(args)
        endpoint_url = 'tickets'

        response = None
        if not args.get('attachments'):
            # The service endpoint to request from
            # Send a request using our http_request wrapper
            response = http_request('POST', endpoint_url, data=json.dumps(args))
        else:
            # Set global HEADERS to the correct content type
            global HEADERS
            del HEADERS['Content-Type']
            # Get the files from their entry IDs
            attachments = entries_to_files(args.get('attachments'))
            # Format to API expectations
            del args['attachments']
            # Send a request and get raw response
            response = http_request('POST', endpoint_url, data=args, files=attachments)
            # Update HEADERS back to their norm
            HEADERS['Content-Type'] = 'application/json'
        return response


    def create_ticket_command():
        """
        One line summary.

        demisto parameter: (string) name
            Name of the requester

        demisto parameter: (number) requester_id
            User ID of the requester. For existing contacts, the
            requester_id can be passed instead of the requester's email.

        demisto parameter: (string) email
            Email address of the requester. If no contact exists with
            this email address in Freshdesk, it will be added as a new contact.

        demisto parameter: (string) facebook_id
            Facebook ID of the requester. If no contact exists with this
            facebook_id, then a new contact will be created.

        demisto parameter: (string) phone
            Phone number of the requester. If no contact exists with this
            phone number in Freshdesk, it will be added as a new contact.
            If the phone number is set and the email address is not, then
            the name attribute is mandatory.

        demisto parameter: (string) twitter_id
            Twitter handle of the requester. If no contact exists with this
            handle in Freshdesk, it will be added as a new contact.

        demisto parameter: (string) unique_external_id
            External ID of the requester. If no contact exists with this
            external ID in Freshdesk, they will be added as a new contact.

        demisto parameter: (string) subject
            Subject of the ticket. The default Value is null.

        demisto parameter: (string) type
            Helps categorize the ticket according to the different kinds of
            issues your support team deals with. The default Value is null.

        demisto parameter: (number) status
            Status of the ticket. The default Value is 2.

        demisto parameter: (number) priority
            Priority of the ticket. The default value is 1.

        demisto parameter: (string) description
            HTML content of the ticket.

        demisto parameter: (number) responder_id
            ID of the agent to whom the ticket has been assigned

        demisto parameter: (array) attachments
            Ticket attachments. The total size of these attachments cannot exceed 15MB.

        demisto parameter: (array) cc_emails
            Email address added in the 'cc' field of the incoming ticket email

        demisto parameter: (dict) custom_fields
            Key value pairs containing the names and values of custom fields.

        demisto parameter: (datetime) due_by
            Timestamp that denotes when the ticket is due to be resolved

        demisto parameter: (number) email_config_id
            ID of email config which is used for this ticket. (i.e.,
            support@yourcompany.com/sales@yourcompany.com) If product_id
            is given and email_config_id is not given, product's primary
            email_config_id will be set

        demisto parameter: (datetime) fr_due_by
            Timestamp that denotes when the first response is due

        demisto parameter: (number) group_id
            ID of the group to which the ticket has been assigned. The default
            value is the ID of the group that is associated with the given email_config_id

        demisto parameter: (number) product_id
            ID of the product to which the ticket is associated. It will be
            ignored if the email_config_id attribute is set in the request.

        demisto parameter: (number) source
            The channel through which the ticket was created. The default value is 2.

        demisto parameter: (array) tags
            Tags that have been associated with the ticket

        demisto parameter: (number) company_id
            Company ID of the requester. This attribute can only be set if the
            Multiple Companies feature is enabled

        returns:
            Ticket (JSON) object
        """
        # Get command arguments from user
        args = demisto.args()

        # Handle additional_fields and additional_values command arguments
        args, additional_fields, additional_values = addional_fields_to_args(args, 'additional_fields', 'additional_values')

        # Make request and get raw response
        ticket = create_ticket(args)
        # Parse response into context
        global DEFAULT_TICKET_CONTEXT_FIELDS
        include_in_context = DEFAULT_TICKET_CONTEXT_FIELDS

        context = {string_to_context_key(key): val for key, val in ticket.iteritems() if key in include_in_context}
        context = additional_fields_to_context(context, include_in_context, additional_fields, additional_values)
        context = attachments_into_context(ticket, context)
        title = "Newly Created Ticket #{}".format(context.get('Id'))
        md = tableToMarkdown(title, context, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': ticket,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                'FD.Ticket(val.Id && val.Id === obj.Id)': context
            }
        })


    def update_ticket(args):
        # Get ticket number
        ticket_number = args.get('id')
        # Remove ticket number from args
        del args['id']

        args = determine_agent(args, 'assigned_agent')
        args = determine_group(args, 'assigned_group')

        # Format args according to API expecations
        additional_update_fields = args.get('update_fields')
        additional_field_values = args.get('update_values')
        args = reformat_args(args, 'update_fields', 'update_values')

        demisto.log('args preclean: {}'.format(args))

        args = clean_arguments(args)
        demisto.log('args postclean: {}'.format(args))

        # The service endpoint to request from
        endpoint_url = 'tickets/{}'.format(ticket_number)

        response = None
        if not args.get('attachments'):
            # Send a request using our http_request wrapper
            demisto.log('args: {}'.format(args))
            response = http_request('PUT', endpoint_url, data=json.dumps(args))
            # response = http_request('PUT', endpoint_url, data=args)
        else:
            # Set global HEADERS to the correct content type
            global HEADERS
            del HEADERS['Content-Type']
            # Get the files from their entry IDs
            attachments = entries_to_files(args.get('attachments'))
            # Format to API expectations
            del args['attachments']
            # Send a request and get raw response
            response = http_request('PUT', endpoint_url, data=args, files=attachments)
            # Update HEADERS back to their norm
            HEADERS['Content-Type'] = 'application/json'
        return response


    def update_ticket_command():
        args = demisto.args()
        args, additional_fields, additional_fields_values = addional_fields_to_args(args, 'update_fields', 'update_values')

        demisto.log('args: {}'.format(args))
        # Make request and get raw response
        ticket = update_ticket(args)

        # Parse response into context
        global DEFAULT_TICKET_CONTEXT_FIELDS
        include_in_context = DEFAULT_TICKET_CONTEXT_FIELDS[:]
        include_in_context.append('updated_at')
        # Parse default context fields
        context = {string_to_context_key(key): val for key, val in ticket.iteritems() if key in include_in_context}
        # Parse additional fields into context
        context = additional_fields_to_context(context, include_in_context, additional_fields, additional_fields_values)
        # Parse attachments into context
        context = attachments_into_context(ticket, context)
        title = "Ticket #{} Updated".format(context.get('Id'))
        md = tableToMarkdown(title, context, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': ticket,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                'FD.Ticket(val.Id && val.Id === obj.Id)': context
            }
        })


    def view_ticket(args):
        ticket_number = args.get('id')
        endpoint_url = 'tickets/{}'.format(ticket_number)
        url_params = {}

        # Check if embedding additional info in API response was specified in cmd args
        include = ''
        if args.get('include_stats') and args.get('include_stats').lower() == 'yes':
            include += 'stats'
        if args.get('include_requester') and args.get('include_requester').lower() == 'yes':
            include += 'requester' if include == '' else ', requester'
        if include != '':
            url_params['include'] = include

        response = http_request('GET', endpoint_url, params=url_params)
        return response


    def view_ticket_command():
        # Get command arguments from user
        args = demisto.args()
        # Make request and get raw response
        ticket = view_ticket(args)

        nonstd_ctx_fields = ['requester', 'stats']

        # Parse response into context
        context = {
            string_to_context_key(key): val
            for key, val in ticket.iteritems()
            if key not in nonstd_ctx_fields and val is not None
        }
        # Parse attachments into context
        context = attachments_into_context(ticket, context)

        context['AdditionalFields'] = {}
        requester = ticket.get('requester')
        if requester:
            requester_context = {string_to_context_key(key): val for key, val in requester.iteritems() if val}
            context['AdditionalFields']['Requestor'] = requester_context
        stats = ticket.get('stats')
        if stats:
            stats_context = {string_to_context_key(key): val for key, val in stats.iteritems() if val}
            context['AdditionalFields']['Stats'] = stats_context

        title = "Viewing Ticket #{}".format(ticket.get('id'))
        md = tableToMarkdown(title, context, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': ticket,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                'FD.Ticket(val.Id && val.Id === obj.Id)': context
            }
        })


    def delete_ticket(ticket_id):
        endpoint_url = 'tickets/{}'.format(ticket_id)
        response = http_request('DELETE', endpoint_url)
        return response


    def delete_ticket_command():
        ticket_id = demisto.args().get('id')
        # Make request
        response = delete_ticket(ticket_id)
        message = "Soft-Deleted Ticket #{}".format(ticket_id)
        demisto.results(message)


    def list_tickets(args):
        endpoint_url = 'tickets'
        url_params = {}

        ## Filter By ##
        filter = args.get('filter')
        if filter:
            url_params['filter'] = filter
        requester = args.get('requester')
        if requester:
            if '@' in requester:
                url_params['email'] = requester
            else:
                url_params['requester_id'] = requester
        company_id = args.get('company_id')
        if company_id:
            url_params['company_id'] = company_id
        updated_since = args.get('updated_since')
        if updated_since:
            url_params['updated_since'] = updated_since

        ## Sort By ##
        order_by = args.get('order_by')
        if order_by:
            url_params['order_by'] = order_by
        order_type = args.get('order_type')
        if order_type:
            url_params['order_type'] = order_type

        ## Embeddings (include additional information) ##
        include = ''
        if args.get('include_stats') and args.get('include_stats').lower() == 'yes':
            include += 'stats'
        if args.get('include_requester') and args.get('include_requester').lower() == 'yes':
            include += 'requester' if include == '' else ', requester'
        if args.get('include_description') and args.get('include_description').lower() == 'yes':
            include += 'description' if include == '' else ', description'
        if include != '':
            url_params['include'] = include

        ## Custom Query ##
        custom_query = args.get('custom_query')
        if custom_query and url_params:
            err_msg = "You cannot use the custom_query argument in conjunction with the other command arguments. You can " \
                      "either use the other arguments that allow you to choose options for filtering, sorting, " \
                      "and including information for tickets, or to use the custom_query alone to create a custom filter " \
                      "that determines which tickets are listed."
            return_error(err_msg)
        elif custom_query:
            endpoint_url = 'search/tickets'
            url_params['query'] = "\"" + custom_query + "\""

        page = args.get('page')
        if page:
            url_params['page'] = page

        # Make request and get raw response
        response = http_request('GET', endpoint_url, params=url_params)
        return response


    def list_tickets_command():
        args = demisto.args()
        additional_fields = get_additional_fields(args)
        response = list_tickets(args)   # page 1

        tickets = handle_list_tickets_pagination(args, response)

        global DEFAULT_TICKET_CONTEXT_FIELDS
        ctx_outputs = DEFAULT_TICKET_CONTEXT_FIELDS[:]
        ctx_outputs.append('updated_at')

        # Parse response into context
        contexts = []
        for ticket in tickets:
            # Parse ticket into the standard outputs
            context = {string_to_context_key(key): val for key, val in ticket.iteritems() if key in ctx_outputs}

            # Parse ticket for the additionally requested fields
            context['AdditionalFields'] = {string_to_context_key(key): val for key, val in ticket.iteritems() if key in additional_fields}
            requester = ticket.get('requester')
            if requester:
                requester_context = {string_to_context_key(key): val for key, val in requester.iteritems() if val}
                context['AdditionalFields']['Requestor'] = requester_context
            stats = ticket.get('stats')
            if stats:
                stats_context = {string_to_context_key(key): val for key, val in stats.iteritems() if val}
                context['AdditionalFields']['Stats'] = stats_context


            # Parse ticket attachments into context
            context = attachments_into_context(ticket, context)

            contexts.append(context)

        title = "Viewing All Requested Tickets"
        md = tableToMarkdown(title, contexts, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': tickets,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                'FD.Ticket(val.Id && val.Id === obj.Id)': contexts
            }
        })



    '''<------ CONVERSATIONS ------>'''


    def ticket_reply(args):
        ticket_id = args.get('ticket_id')
        del args['ticket_id']
        args = handle_array_input(args)
        endpoint_url = 'tickets/{}/reply'.format(ticket_id)

        # Handle potential attachments
        response = None
        if not args.get('attachments'):
            # The service endpoint to request from
            # Send a request using our http_request wrapper
            response = http_request('POST', endpoint_url, data=json.dumps(args))
        else:
            # Set global HEADERS to the correct content type
            global HEADERS
            del HEADERS['Content-Type']
            # Get the files from their entry IDs
            attachments = entries_to_files(args.get('attachments'))
            # Format to API expectations
            del args['attachments']
            # Send a request and get raw response
            response = http_request('POST', endpoint_url, data=args, files=attachments)
            # Update HEADERS back to their norm
            HEADERS['Content-Type'] = 'application/json'
        return response


    def ticket_reply_command():
        args = demisto.args()
        # Make request and get raw response
        reply = ticket_reply(args)
        # Parse response into context
        context = {string_to_context_key(key): val for key, val in reply.iteritems() if val}
        # Parse attachments into context
        context = attachments_into_context(reply, context)
        title = "Reply to Ticket #{}".format(reply.get('ticket_id'))
        md = tableToMarkdown(title, context, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': reply,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                'FD.Ticket(val.Id && val.Id === obj.Id).Conversation(val.Id && val.Id === obj.Id)': context
            }
        })


    def ticket_note(args):
        ticket_id = args.get('ticket_id')
        del args['ticket_id']
        args = handle_array_input(args)
        # Set defaults for 'private' and 'incoming' fields if not set by user
        args['private'] = args.get('private', 'True')
        args['incoming'] = args.get('incoming', 'False')
        args = handle_bool_input(args)
        endpoint_url = 'tickets/{}/notes'.format(ticket_id)

        response = None
        if not args.get('attachments'):
            # Format boolean args to API expectations
            dumped_args = json.dumps(args).replace("\"false\"", "false").replace("\"true\"", "true")
            # The service endpoint to request from
            # Send a request using our http_request wrapper
            response = http_request('POST', endpoint_url, data=dumped_args)
        else:
            # Set global HEADERS to the correct content type
            global HEADERS
            del HEADERS['Content-Type']
            # Get the files from their entry IDs
            attachments = entries_to_files(args.get('attachments'))
            # Format to API expectations
            del args['attachments']
            # Send a request and get raw response
            response = http_request('POST', endpoint_url, data=args, files=attachments)
            # Update HEADERS back to their norm
            HEADERS['Content-Type'] = 'application/json'
        return response


    def ticket_note_command():
        # Get command arguments
        args = demisto.args()
        # Make request and get raw response
        note = ticket_note(args)
        # Parse response into context
        context = {string_to_context_key(key): val for key, val in note.iteritems() if val}
        # Parse attachments into context
        context = attachments_into_context(note, context)
        title = 'Note for Ticket #{}'.format(note.get('ticket_id'))
        md = tableToMarkdown(title, context, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': note,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                'FD.Ticket(val.Id && val.Id === obj.Id).Conversation(val.Id && val.Id === obj.Id)': context
            }
        })


    def get_conversations(ticket_id):
        endpoint_url = 'tickets/{}/conversations'.format(ticket_id)
        response = http_request('GET', endpoint_url)
        return response


    def get_conversations_command():
        # Get id number of ticket as cmd arg for which you want to see all the conversations
        ticket_id = demisto.args().get('ticket_id')
        # Make request and get raw response
        conversations = get_conversations(ticket_id)
        # Parse response into context
        contexts = []
        for conversation in conversations:
            context = {string_to_context_key(key): val for key, val in conversation.iteritems() if val}
            # Parse attachments into context
            context = attachments_into_context(conversation, context)
            contexts.append(context)
        title = 'Conversations of Ticket #{}'.format(ticket_id)
        md = tableToMarkdown(title, contexts, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': conversations,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                'FD.Ticket(val.Id && val.Id === obj.Id).Conversation(val.Id && val.Id === obj.Id)': contexts
            }
        })


    '''<------ CONTACTS ------>'''


    def list_contacts(filters):
        # Alter to match API expected inputs
        updated_since = filters.get('updated_since', None)
        if updated_since:
            del filters['updated_since']
            filters['_updated_since'] = updated_since

        endpoint_url = 'contacts'
        response = http_request('GET', endpoint_url, params=filters)
        return response


    def list_contacts_command():
        # Get command arguments from user
        filters = demisto.args()
        # Make request and get raw response
        contacts = list_contacts(filters)
        # Parse response into context
        contexts = []
        for contact in contacts:
            # Parse individual contact response in context
            context = {string_to_context_key(key): val for key, val in contact.iteritems() if val}
            contexts.append(context)
        filters_as_strings = ', '.join(['{}: {}'.format(key, val) for key, val in filters.iteritems()])
        title = "Contacts Filtered by {}".format(filters_as_strings) if filters else "All Contacts"
        md = tableToMarkdown(title, contexts, removeNull=False)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contacts,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                'FD.Contact(val.Id && val.Id === obj.Id)': contexts
            }
        })


    def view_contact(args):
        contact_id = 0
        if not args:
            err_msg = 'You must provide a value for either the mobile, email or id command argument fields.'
            return_error(err_msg)
        elif args.get('id') is not None:
            contact_id = args.get('id')
        elif args.get('email') is not None:
            try:
                filters = {'email': args.get('email')}
                # Get id field of first result of contacts with that email (There should only be one)
                contact_id = list_contacts(filters)[0].get('id')
            # If there is an IndexError, it means no results were returned for the given filter
            except IndexError as e:
                err_msg = "Couldn't find a contact with that email address."\
                            " Double check that you wrote the email address correctly"\
                            " and/or that you have a FreshDesk contact with that exact"\
                            " email address."
                return_error(err_msg)
            except Exception as e:
                return_error(e.message)
        else:
            try:
                filters = {'mobile': args.get('mobile')}
                # Get id field of first result of contacts with that mobile number
                contact_id = list_contacts(filters)[0].get('id')
            # If there is an IndexError, it means no results were returned for the given filter
            except IndexError as e:
                err_msg = "Couldn't find a contact with that mobile number."\
                        " Double check that you wrote it correctly and/or that "\
                        "you have a FreshDesk contact with that exact mobile number."
                return_error(err_msg)
            except Exception as e:
                return_error(e.message)

        endpoint_url = 'contacts/{}'.format(contact_id)
        response = http_request('GET', endpoint_url)
        return response


    def view_contact_command():
        # Get command arguments from user
        # contact_id = demisto.args().get('id')
        args = demisto.args()
        # Make request and get raw response
        contact = view_contact(args)
        # Parse response into context
        context = {string_to_context_key(key): val for key, val in contact.iteritems() if val}
        title = "Viewing Contact #{}".format(contact.get('id'))
        md = tableToMarkdown(title, context, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': contact,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                'FD.Contact(val.Id && val.Id === obj.Id)': context
            }
        })


    '''<------ CANNED RESPONSES ------>'''


    def list_cr_folders():
        endpoint_url = 'canned_response_folders'
        response = http_request('GET', endpoint_url)
        return response


    def list_cr_folders_command():
        # Make request and get raw response
        cr_folders = list_cr_folders()
        # Parse response into context
        contexts = []
        for folder in cr_folders:
            # Parse individual contact response in context
            context = {string_to_context_key(key): val for key, val in folder.iteritems() if val}
            contexts.append(context)
        title = "All Canned Response Folders"
        md = tableToMarkdown(title, contexts, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': cr_folders,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                'FD.CRFolder(val.Id && val.Id === obj.Id)': contexts
            }
        })


    def list_crs_in_folder(id):
        endpoint_url = 'canned_response_folders/{}'.format(id)
        response = http_request('GET', endpoint_url)
        return response


    def list_crs_in_folder_command():
        # Get id of the containing canned response folder as cmd argument
        cr_folder_id = demisto.args().get('id')
        # Make request and get raw response
        canned_responses = list_crs_in_folder(cr_folder_id)
        # Parse response into context
        contexts = []
        for cr in canned_responses.get('canned_responses'):
            context = {string_to_context_key(key): val for key, val in cr.iteritems() if val}
            contexts.append(context)
        title = "Canned Responses in Folder #{}".format(canned_responses.get('id'))
        md = tableToMarkdown(title, contexts, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': canned_responses,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                'FD.CRFolder(val.Id && val.Id === obj.Id).CR(val.Id && val.Id === obj.Id)': contexts
            }
        })


    def detail_crs(id):
        endpoint_url = 'canned_response_folders/{}/responses'.format(id)
        response = http_request('GET', endpoint_url)
        return response


    def detail_crs_command():
        # Get id of the containing canned response folder as cmd argument
        cr_folder_id = demisto.args().get('id')
        # Make request and get raw response
        canned_responses = detail_crs(cr_folder_id)
        # Parse the responses into context
        contexts = []
        for cr in canned_responses:
            context = {string_to_context_key(key): val for key, val in cr.iteritems() if val}
            contexts.append(context)
        title = "Details of Canned Responses in CR Folder #{}".format(cr_folder_id)
        md = tableToMarkdown(title, contexts, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': canned_responses,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                'FD.CRFolder(val.Id && val.Id === obj.Id).CR(val.Id && val.Id === obj.Id)': contexts
            }
        })


    '''<------ GROUPS ------>'''


    def list_groups():
        endpoint_url = 'groups'
        response = http_request('GET', endpoint_url)
        return response


    def list_groups_command():
        # Make request and get raw response
        groups = list_groups()
        # Parse response into context
        contexts = []
        for group in groups:
            # Parse individual group response in context
            context = {string_to_context_key(key): val for key, val in group.iteritems() if val}
            contexts.append(context)
        title = "All Groups"
        md = tableToMarkdown(title, contexts, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': groups,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                'FD.Group(val.Id && val.Id === obj.Id)': contexts
            }
        })


    '''<------ AGENTS ------>'''


    def list_agents(filters):
        endpoint_url = 'agents'
        response = http_request('GET', endpoint_url, params=filters)
        return response


    def list_agents_command():
        # Get filter as cmd arg
        args = demisto.args()
        # Make request and get raw response
        agents = list_agents(args)
        # Parse response into context
        contexts = []
        for agent in agents:
            # Parse the individual agent into context
            context = {string_to_context_key(key): val for key, val in agent.iteritems() if val}
            context['Contact'] = {string_to_context_key(key): val for key, val in agent.get('contact').iteritems() if val}
            contexts.append(context)
        title = "All Agents"
        md = tableToMarkdown(title, contexts, removeNull=True)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': agents,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': md,
            'EntryContext': {
                'FD.Agent(val.Id && val.Id === obj.Id)': contexts
            }
        })


    ''' COMMANDS MANAGER / SWITCH PANEL '''


    # Commands Switch Panel
    commands = {
        "fd-create-ticket": create_ticket_command,
        "fd-update-ticket": update_ticket_command,
        "fd-view-ticket": view_ticket_command,
        "fd-view-contact": view_contact_command,
        "fd-list-contacts": list_contacts_command,
        "fd-list-cr-folders": list_cr_folders_command,
        "fd-list-crs-in-folder": list_crs_in_folder_command,
        "fd-detail-crs": detail_crs_command,
        "fd-list-groups": list_groups_command,
        "fd-ticket-reply": ticket_reply_command,
        "fd-ticket-note": ticket_note_command,
        "fd-get-conversations": get_conversations_command,
        "fd-list-agents": list_agents_command,
        "fd-delete-ticket": delete_ticket_command,
        "fd-list-tickets": list_tickets_command,
    }

    LOG('Command being called is %s' % (demisto.command()))

    try:
        if demisto.command() == 'test-module':
            # This is the call made when pressing the integration test button.
            test_module()
            demisto.results('ok')
        elif demisto.command() == 'fetch-incidents':
            fetch_incidents()
        elif demisto.command() in commands.keys():
            # Execute that command
            commands[demisto.command()]()

    # Log exceptions
    except Exception as e:
        LOG(e)

        ex_type, ex, tb = sys.exc_info()
        traceback.print_tb(tb)
        return_error(e.message)
  type: python
