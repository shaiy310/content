commonfields:
  id: Attivo Botsink
  version: -1
name: Attivo Botsink
display: Attivo Botsink
category: Deception
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKIAAABLCAMAAADEZ6xjAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MjkzREQ4NEM1MzkxMTFFNkFBNUJBNjYwQjczNjgyMzIiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MjkzREQ4NEQ1MzkxMTFFNkFBNUJBNjYwQjczNjgyMzIiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoyOTNERDg0QTUzOTExMUU2QUE1QkE2NjBCNzM2ODIzMiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoyOTNERDg0QjUzOTExMUU2QUE1QkE2NjBCNzM2ODIzMiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pj0B2NAAAAMAUExURf6WU11dYf/r3jY8RJGRlXl5fMzNztzd3m1yd/7StXFxdf/59bGytf1tEUxRWB4lLf68ks7P0PDw8GtrbiMpMv18Kf/t4oKGiv6iZ5WVl9DR0o2Qlf6RTP/l1crLzaKipP/x6dLU1URKUf16Jf6teIqKjZqbnf/8+p6foa+vsf/28r6+wPr6+3+DiPLy84KChf/dyP6ygv7AmcXHyYqOktXV1oWIjf1yGKurrbm5uurq6qSnq97f4MHBw7a2uP6rdS40PP6aWv2GOpqdof61hv/gzpGUmGRkaP66jpSXmpycnv1xFqCgom5ucru7vNra23V1eHl9gv6dYGNobv7VulZbYdjY2WBgZDxCSXR4fZ+ipejo6P6nbsPDxP/o2RYdJVpaXsnJy/7WvGNjZu7v7/7OrX19gOvr7GpudObm55aanbe5vP2ORuDg4f/cxv2IPVhYXLCwshohKqioquzs7UFGTeTk5f6wftrb3P1sDs7Q0mZmanB0epiYmmZrcOHh4v7Yv/2KQP7GorO2uP/1715iaFpfZf2BMf7En/64i/6jaXN3fP2MQ/2DNYyMjzE3PxEYISsxOf1rDVZWWoiLkMPFx7W1t1tgZoCAg/z8/MrKy/10G/T09VdXW/f39xIZIv39/f/+/bq8v/X19eHi4xMaI//9/KGkp+np6uvs7fj4+Ofn6Pb29qSkpv/7+P7+/uPk5Wxsb/n6+hgfKNjZ2mJnbbS3ufj4+fj5+f7Mq62tr8vMzsHDxv13IU9UWtna2//j0fn5+YWFiOTl5tPT1LW3uiwyOnd7gMDCxbi6vVJXXqeqrcTExY2NkBgeJ3d3ev2ENhQbJFNYX6+xtP/w5ktQV/1uE9fX2MjIyf6ka/11HvT09LK0tvb29ycuNtvc3fv7+/2ALsbIyv7Qsry8vuLj5PHx8VBVW6msrxsiK/62iO/w8Ozt7u3u7v/z7N/g4f/k0lhdY2dna+Xm5/7DnIiIi+Pj48DBxB8mLv7Tt/7KqHZ2ebm7vv6gY6utsf///0JJPWAAAAEAdFJOU////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////wBT9wclAAAJZUlEQVR42uyZe1wUxx3AeYixiAoBY44oSFNRgkCIQYWA4gsURSGJQnye0agxqTYmKjYgMYnm0SRu7qdXL4KgKCLg+y3GB9GYxDSJjVLzrPZBmzZNW5o22tZOZ36ztzuzd3t615IPn0+YP3Z/85vd2e/NzO8xc36kzRe/dsR2xHbE/x3x6q2sLG3LiCtsWE6YNL9xVK5XnhUqA84M/G3rI/bihLapblv7Zy1aIynCFl/RK/9RFCVic6sj/kBFHHSHm8ajgYoiIs4urlAExMAKytijtRH7vq4i2r52bRxICUTEX0bQuoD4OWv/SWsj/prR9WSX4a6NPzUgrlVkxAdYPb61Ef0Y3YJB7Hqn14j1nSIyJ7e2uZzvQtnGVt/LEG/1GvFbcTqjcZ7JYXZrerZNIj7H2EJJ57H83gYRF6At30LINXa/3BYRX2RkC6nwILI+1dqIGwaMSMjP77G1Y/8bReyMlvwClapvZ9IwoW1+ZmbmIkSiQuZ+kkiv6AcrWD1zH3tmP5PmMymfSYsrDf0fx0fDnNVvVu5V1NJtXsyNIT6NYxegBZku5/W2NYpYupJmqa7gF7pqo/w2Ktca+u/BlG+q4EVd5R6Wz70RxEcZ16MonkDaP/iK6MAB7mToP5MpB3L57F7FUD5vuD7idMR6mleGM7l7tY+IJAHXxCGp/wH4ZDrKIzSwwsIrqrho7XURlzKqsWr6EIq839Maa2JiYhChmAox6cRBr1tZ/QtWj9lgQCzCjz4j9d+JqS6geIBDRdxdymoxZ2bwFVl0HURuItfUWu9lrObnlUULiOT7TF4pvl3bjanuYeJcPnDvbHO27QtExeJLnhGvyo4Go/WyAF8RJzN5RrPw9oc45mVMLEagVQ698UvOONkz4jBcfRudVQyCtqW+Iiaih9oqvP1XppjHpDSc19VVYt/p+PybDk+IXzUxpGTdSa5n9df7+ohIlnOz0sq2c5ofGoMjdlr+PrfHTZ4QQ3WnyMtUVBz2FfEt9OtvaI1ow6tRvKCLQgaPQ1vsCfEDBvSSS8Du6StiJXrBLK0R7edu3AC9x8QEI8BEpg30gDgKgZ4XVZdRNd1HRD5zhc7aTTiouPeKMU4pL1n4RJU54lTRKfIyEhGH+opYiiQp4r7nGIqnscFlp8iD5nFTRG4cfqNEXQAiru/sIyI5Js4nTvvvhciywYgYZojrRsR/Is7VgI9G9zbEbGdE9B7xLKu+yrOGX2H0qOdJE7pMF2PApaA8YorYU/UwG0MHDbvqjMzP25z5o0+I9d30YSkW0oo17tPMzZ4RA5Zpy276Clv3ZO577sD9gW2Uj4g8KCPXIYx4UVw9xv0oHvc80SMFlurQJtuynod3UBF3graPfEWMwtll6U6I6FD6uV+LDahuMEHc2J2hPKed6yyktY+H9iL32yQ79xaRYOD91Pnmbar2GWTZZUQ8YDB0GfEpRBmpJz0vYDRc8TXaue0uXxE7MMV+NXJsqVO1Jn7xNqY95zBBvNcY/Eiv4Ta9vOwrYt0WltxUEUwsf64dr2GoczmeesdTdHm2yRj8COk7sovOuMBHRB7UPuQeMk7TXjDAYPmjxxh9lzSdznJCH8hrAmKCAfE9T4hoJsu3scG8UiuHOuNM4zwrISaIC3G795Vx5HckOweyqbeOmG9AVDwhHmLHexFbDYd6NZiXBdZKp7/oRCMuuUf8i811D6DmFh+ojKP1FHCVMWT92QMiOYOJKruEGXcxyn4hf21erGiZkBvEoUjxkLtt646l6NNtl6u17+3VN+Xp2O0DnhAjnTs9aenV8b3LykSnYhcnXF3rHnHHx4ZsQSp38sm+X8+WZ0yctwrze7JnC+ZPgcvv+12kCSIpVBHHSNo4rnx1xJ8QcCDOsrK3o8kO8CFkeJF4OhTlZydrtW3zF/L31U2KO8T5vP1cjTvjYL+v64VMVZ4RYraP9nN7xCQfLdu63MIS6UANabO+zVM0I3KH+CXfIk80dht7zngaEXHU7DTiPK622zcSzwf0GHr2RVSo/W0S9lCaX3aHSFYqzigol46FEmDFfdtMz3RC17OSbH7ClowPvIy/oabTIkXa8N4TKFjDxCu0dDC8vokpM/e49lsZcmyLNoLF+/5//wHuiXnkQPyPy3TF3946cHrALt86m/3vrPx5xQmTGxxe/cHWZko74ncOMc4SvZPdH7cM0ZujLViWqNUlvJrjbObPTrDE0utBiyVS6LgsLqggO+iIfKRE3+0Xly7GRYuFBr8hFkuKpnIM3j1rTpRbxHUAqeyeB3305nDA4uwghVcLtGwadrM9CEAptp3SXzyVzR/N/oXwsde47oiusQOkkZkA63RTzjI+IyEWzHVF9A+nZYJanRAeXk41ec7mVICbCckFeIzOApTrO6VJVoC8nJxgAGuRhPhkSzmUT5EQl/hDy2w9swAI2p4NjQ73iNDoimgxrIwCUZMOMJNMoS8mEdIHNHJyaTdY8Z/U8eWQ6xARU0gRwHgRsTQYrIK/noRdjrtkMooAGd4hVvrDdjaUYP2MZIO2REkGgJr+HwGYJiOWAXwqIs4BEBY/qaJj+g8Tc1kHubkwq9njRBsRSRLMocMXBPBaHf4+tVjAepBLB/2F5yniz9jkR4qIAHKofIwuuFNmiHkp7HFP5uKC+DhYa/1hfDDE0oGbIvblFIPYIpDNpZHIiBfleYqmk5JhhkhiAaIMiMHjaKkzQwyjM0pXfDSEx0K2rm6EYKf4LxmxHCDEISH+CLITZUZ7ubg6DIj1LdCy24u1SD4BmAW55BS7Ca/lgFX97CdWKBERtwMMJhLiYDr7hm/MtEJBlQkiaWAD7wUioSsL+pH+/oCORxjcfuq5DZ0XyVzmgH+i7BdfEVcxIZ+lEfIbALoL+2HI+GmuiNQZGxA7lNHiMEUsAeytD72JTpqaaTT1kifpoL2/U0KkTmWcjNicDQVPaJqLLXlV7CfSH5YaGz1tgiti8yzwxlxIPKDxUsdjPSmo02hwKUhKKqAL4GEiO52/g3WuHF0aQFiv46h77+MPVhoS4ktKbnrXFZFM8w5xCe8+jcYEaT3UvM/fzHuYGBBLy4UeEJFNheYaT6J/xnpqxhM5iSLiRTu3oni78GdrvB2LPg8k1R4pm599EoYRg5rsjCppTLLM3CnqpmBP79qHaAsn3W6vJ2SD3a4HHEfqK+uy+KLpmHFze77YjtiO2I74bZf/CjAAFGvtiiToBDYAAAAASUVORK5CYII=
configuration:
- display: Botsink name or address
  name: server
  defaultvalue: ""
  type: 0
  required: true
- display: BOTsink API credentials
  name: credentials
  defaultvalue: ""
  type: 9
  required: true
- display: Do not verify server SSL
  name: insecure
  defaultvalue: "False"
  type: 8
  required: false
- display: Minimum severity when fetching events (Very High, High, Medium)
  name: fetch_severity
  defaultvalue: High
  type: 0
  required: true
- display: Fetch incidents
  name: isFetch
  defaultvalue: ""
  type: 8
  required: false
- display: Incident type
  name: incidentType
  defaultvalue: ""
  type: 13
  required: false
- display: Number of days to go back for the first fetch.  '0' means only get new
    incidents.
  name: first_fetch
  defaultvalue: "0"
  type: 0
  required: true
script:
  script: |-
    import requests
    import base64
    import socket
    import json
    import datetime
    import time
    import os

    import urllib3
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    SERVER = demisto.params()['server']
    API_USER = demisto.params()['credentials']['identifier']
    API_PASS = demisto.params()['credentials']['password']
    VERIFY_SSL =  not demisto.params()['insecure']

    class BSAPI:
        BS_DEFAULT_PORT = 8443
        TIMEOUT = 20

        def __init__(self, bs_host, bs_port=BS_DEFAULT_PORT, verify_ssl=False, timeout=TIMEOUT):
            self.bs_host = bs_host
            self.bs_port = bs_port
            self.timeout = timeout
            self.session_key = None
            self.base_url = "https://{host}:{port}/api".format(host=self.bs_host,port=self.bs_port)
            self.verify_ssl = verify_ssl

        def do_request(self, url, data=None, headers=None, files=None, method=None, content_type='application/json', json_dump=True):
            # Guess the method if not provided
            if not method:
                if data: method='post'
                else: method='get'

            headers = {}
            if self.session_key: headers = {'sessionKey': self.session_key}
            if content_type: headers['content-type']=content_type

            url = self.base_url + url
            # Convert data dictionary to a string
            if data and json_dump: data = json.dumps(data)

            request_func = getattr(requests, method)
            r = None

            try:
                r = request_func(url,headers=headers,data=data,files=files,verify=self.verify_ssl)
            except requests.exceptions.SSLError as e:
                demisto.error("SSL verification failed")
                demisto.results("SSL verification to {url} failed".format(url=url))
            except requests.exceptions.ConnectionError as e:
                demisto.error("Could not connect to: {server}".format(server=SERVER))
                demisto.error("Exception: {}".format(e))
                demisto.results("Could not connect to {server} ({exception})".format(server=SERVER, exception=e))
            except Exception, e:
                demisto.error("Generic Exception: {exception}".format(exception=e))
                demisto.error("Type is: {type}".format(type=e.__class__.__name__))

            if r is not None and r.content:
               return r.json()
            else:
               return None

        def login(self, bs_user, bs_pass):
            url="/auth/login"
            login_data = {'userName': base64.b64encode(bs_user), 'password':base64.b64encode(bs_pass)}

            login_status = self.do_request(url,data=login_data)
            if login_status and 'sessionKey' in login_status:
                self.session_key = login_status['sessionKey']

            return (login_status)

        def logout(self):
            url = "/auth/logout"
            logout_status = self.do_request(url)
            return (logout_status)

        def deploy_decoys(self,target_ip,vlan=None,decoy_number=1):
            url = "/autodeploy/config"
            if vlan:
               data = {"config": [{"ipAddress":target_ip,"vlanID": vlan, "numberOfIPsToAcquire": decoy_number}]}
            else:
               data = {"config": [{"ipAddress":target_ip,"numberOfIPsToAcquire": decoy_number}]}

            deploy_status = self.do_request(url,data=data,content_type=None)
            return (deploy_status)

        def get_threatdirect_rules(self):
            url="/nwinterfaces/get"
            td_decoys = self.do_request(url)
            return (td_decoys)

        def get_bs_health(self):
            url="/device/health"
            health = self.do_request(url)
            return health

        def get_monitoring_rules(self):
           url = "/interfaces/get"
           monitoring_rules = self.do_request(url,data='{}',method='post',json_dump=None)
           return (monitoring_rules)

        def get_deceptive_objects(self,object_type,object_id):
            if object_type == 'USERS':
                if object_id == 'ALL':
                    url="/obj_group_cfg/summary/user"
                else:
                    url="/obj_group_cfg/user/{object_id}".format(object_id=object_id)
            else:
                response="Unknown option: {object_type}".format(object_type=object_type)
                return (response)

            deceptive_objects = self.do_request(url)
            return (deceptive_objects)

        def get_playbooks(self):
           url='/pb/getAll'
           return self.do_request(url)

        def run_playbook(self, playbook_id, attacker_ip):
           'This simulates an internal playbook execution based on the attacker IP'
           url='/pb/runplaybook'
           data= {'attacker_ip': attacker_ip, 'playbook_id': playbook_id}
           return self.do_request(url,data=data)

        def get_events(self,severity_start=None, severity_end=None, timestamp_start=None, timestamp_end=None,
                        offset=None, acknowledged='unacknowledged', attacker_ip=None, category=None,
                        device=None, service=None, target_os=None, target_host=None, target_ip=None,
                        target_vlan=None, keywords=None, description=None, comments=None):

            url = "/eventsquery/alerts"

            query_data = {
                'severity_start' : severity_start,
                'severity_end' : severity_end,
                'timestampStart' : timestamp_start,
                'timestampEnd' : timestamp_end,
                'offset' : offset,
                'acknowledged' : acknowledged,
                'attackerIp' : [] if attacker_ip is None else attacker_ip,
                'category' : [] if category is None else category,
                'device' : [] if device is None else device,
                'service' : [] if service is None else service,
                'targetOs' : [] if target_os is None else target_os,
                'targetHost' : [] if target_host is None else target_host,
                'targetIP' : [] if target_ip is None else target_ip,
                'targetVLAN' : [] if target_vlan is None else target_vlan,
                'keywords' : [] if keywords is None else keywords,
                'description' : [] if description is None else description,
                'comments' : [] if comments is None else comments
            }

            event_data = self.do_request(url,data=query_data)
            return (event_data)

        def convert_severity_string(self, severity_string):
            conversion = {
                'VeryHigh': 14,
                'Very High': 14,
                'High': 11,
                'Medium': 7,
                'Low': 4,
                'VeryLow': 3,
                'Very Low': 3,
                'SystemActivity': 0,
                'System Activity': 0
            }
            if severity_string in conversion:
                return conversion[severity_string]
            else:
                return None

        def convert_to_demisto_severity(self,attivo_severity):
            if attivo_severity >= 14:   # Very High
                demisto_severity = 3
            elif attivo_severity >= 11: # High
                demisto_severity = 3
            elif attivo_severity >= 7: # Medium
                demisto_severity = 2
            else:                      # Low
                demisto_severity = 1

            return demisto_severity


    def valid_ip(host):
        try:
            socket.inet_aton(host)
            return True
        except:
            return False

    def date_to_epoch(date):
        date_pattern1 = '\d{4}-\d{2}-\d{2}$'
        date_format1 = '%Y-%m-%d'
        date_pattern2 = '\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}Z$'
        date_format2 = '%Y-%m-%dT%H:%M:%SZ'

        epoch = None
        if re.match(date_pattern2, date):
            epoch = int(time.mktime(time.strptime(date, date_format2))) * 1000
        elif re.match(date_pattern1, date):
            epoch = int(time.mktime(time.strptime(date, date_format1))) * 1000

        return epoch

    ''' EXECUTION CODE '''
    attivo_api = BSAPI(SERVER, verify_ssl=VERIFY_SSL)

    if demisto.command() == 'attivo-get-events':
        args = demisto.args()
        login_status = attivo_api.login(API_USER, API_PASS)
        attacker_ip = args['attacker_ip']
        severity_string = args['severity']

        start_date = args.get('alerts_start_date')
        if start_date is not None:
            timestampStart = date_to_epoch(start_date)
        else:
            one_day = 24 * 60 * 60
            timestampStart = (int(time.time()) - one_day) * 1000

        end_date = args.get('alerts_end_date')
        if end_date is not None:
            timestampEnd = date_to_epoch(end_date)
        else:
            timestampEnd = int(time.time()) * 1000

        if timestampEnd is None:
            demisto.info("Bad date: {}\nDate should be of the format yyyy-mm-dd or yyyy-mm-ddThh:mm:ssZ".format(end_date))
            return_error("Bad date: {}\nDate should be of the format yyyy-mm-dd or yyyy-mm-ddThh:mm:ssZ".format(end_date))

        if timestampStart is None:
            demisto.info("\nBad date: {}\nDate should be of the format yyyy-mm-dd or yyyy-mm-ddThh:mm:ssZ".format(start_date))
            return_error("\nBad date: {}\nDate should be of the format yyyy-mm-dd or yyyy-mm-ddThh:mm:ssZ".format(start_date))

        severity_end = "15"
        severity_start = attivo_api.convert_severity_string(severity_string)
        attacker_ips = [attacker_ip]

        demisto.info("Pulling events for {src_ip} and severity {severity} from {start_date} to {end_date}".format(src_ip=attacker_ip, severity=severity_start, start_date=timestampStart, end_date=timestampEnd))

        events = attivo_api.get_events(severity_start=severity_start, severity_end=severity_end, timestamp_start=timestampStart, timestamp_end=timestampEnd, attacker_ip=attacker_ips)

        attivo_api.logout()

        brief_events = []
        context = []
        for event in events['eventdata']:
            brief_events.append({
                'Attack Name': event['attackName'],
                'Severity' : event['details']['Severity'],
                'Target IP': event['details']['Target IP'],
                'Target OS': event['details']['Target OS'],
                'Timestamp': event['details']['Timestamp'],
            })
            context.append(event['details'])

        headers = ['Attack Name', 'Severity', 'Timestamp', 'Target IP', 'Target OS']
        entry = {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': events['eventdata'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Found {} events:'.format(len(brief_events)), brief_events, headers=headers),
            'EntryContext': {'Attivo.Events.Count': len(events['eventdata']),
                             'Attivo.Events.List': context}
        }

        demisto.results(entry)

    if demisto.command() == 'fetch-incidents':
        login_status = attivo_api.login(API_USER, API_PASS)
        date_pattern = "%Y-%m-%dT%H:%M:%S.%fZ"
        os.environ['TZ'] = 'UTC'

        FETCH_SEVERITY = demisto.params()['fetch_severity']
        FIRST_FETCH = int(demisto.params()['first_fetch'])

        severity_start = attivo_api.convert_severity_string(FETCH_SEVERITY)
        if not severity_start:
            demisto.info("Attivo fetch-incidents: Unknown severity specified ('{}') using Medium".format(FETCH_SEVERITY))
            severity_start = 7 # Medium
        severity_end = 15 # Very High

        # TEST CODE
        #demisto.setLastRun({'time': None})
        #demisto.info("FIRST FETCH {}".format(FIRST_FETCH))
        #TEST CODE

        # When run for the first time, get events from the specified number of days
        one_day = 24 * 60 * 60
        first_fetch_seconds = (int(time.time()) - (one_day * FIRST_FETCH)) * 1000
        #last_run_time = demisto.getLastRun().get('time', first_fetch_seconds)
        last_run_time = demisto.getLastRun().get('time', None)

        if last_run_time is None or last_run_time == 0:
            last_run_time = first_fetch_seconds

        demisto.info("Attivo fetch-incidents: Last run time {}, severity {}:{}".format(last_run_time, FETCH_SEVERITY, severity_start))
        #sys.exit()

        new_last_run = 0
        incidents = []

        events = attivo_api.get_events(timestamp_start=last_run_time, timestamp_end='now',
                                       severity_start=severity_start, severity_end=severity_end)
        if 'error' in events:
            demisto.error("fetch-incidents error: {}".format(events['error']))
            sys.exit()

        demisto.info("Total new Attivo incidents to add: {}".format(len(events['eventdata'])))

        for event in events['eventdata']:
            event_date = event['timeStamp']
            event_time = int(time.mktime(time.strptime(event_date,date_pattern))) * 1000
            new_last_run = max(new_last_run, event_time)
            demisto_severity = attivo_api.convert_to_demisto_severity(event['alertLevel'])
            event_type = event['details']['Attack Phase']
            incidents.append({
                'name': event['attackName'],
                'occurred': event_date,
                'details': event['attackDesc'],
                'severity': demisto_severity,
                'type': event_type,
                'rawJSON': json.dumps(event)
            })

        if len(incidents) > 0:
            demisto.info("Setting new last run value to {}".format(new_last_run))
            demisto.setLastRun({'time': new_last_run})
        else:
            demisto.info("No new Attivo incidents to add")

        logout_status = attivo_api.logout()
        demisto.incidents(incidents)

    if demisto.command() == 'test-module':
        # This is the call made when pressing the integration test button.
        login_status = attivo_api.login(API_USER, API_PASS)

        if login_status and 'sessionKey' in login_status:
            demisto.info("Attivo Login successful (session key = {})".format(login_status['sessionKey']))
            logout_status = attivo_api.logout()
            demisto.results('ok')
            sys.exit(0)
        else:
            demisto.error("Login to {} failed".format(SERVER))
            demisto.error("API Results: {}".format(login_status))
            demisto.results("Login to {} failed\n{}".format(SERVER,login_status))

    if demisto.command() == 'attivo-list-playbooks':
        login_status = attivo_api.login(API_USER, API_PASS)
        all_playbooks = attivo_api.get_playbooks()
        brief_playbooks=[]
        for playbook in all_playbooks['pb']:
            brief_playbook = {
                'ID': playbook['id'],
                'Name': playbook['name']
            }
            demisto.info("INVESTIGATE {}".format(playbook['investigate']))
            if len(playbook['investigate']) > 0:
                investigate_names = []
                for investigate in playbook['investigate']:
                   investigate_names.append(investigate['name'])
                brief_playbook['Investigate'] = ', '.join(investigate_names)
            else:
                brief_playbook['Investigate'] = []

            if len(playbook['analyze']) > 0:
                analyze_names = []
                for analyze in playbook['analyze']:
                   analyze_names.append(analyze['name'])
                brief_playbook['Analyze'] = ', '.join(analyze_names)
            else:
                brief_playbook['Analyze'] = []

            if len(playbook['manage']) > 0:
                manage_names = []
                for manage in playbook['manage']:
                   manage_names.append(manage['name'])
                brief_playbook['Manage'] = ', '.join(manage_names)
            else:
                brief_playbook['Manage'] = []

            if len(playbook['isolate']) > 0:
                isolate_names = []
                for isolate in playbook['isolate']:
                   isolate_names.append(isolate['name'])
                brief_playbook['Isolate'] = ', '.join(isolate_names)
            else:
                brief_playbook['Isolate'] = []

            brief_playbooks.append(brief_playbook)

        headers = ['Name', 'ID', 'Investigate', 'Analyze', 'Manage', 'Isolate']
        entry = {
            'Type': entryTypes['note'],
            'Contents': brief_playbooks,
            'ContentsFormat': formats['json'],
            'HumanReadable': tableToMarkdown('Attivo playbooks', brief_playbooks, headers=headers),
            'ReadableContentsFormat': formats['markdown'],
            'EntryContext': {}
        }

        demisto.results(entry)
        logout_status = attivo_api.logout()

    if demisto.command() == 'attivo-run-playbook':
        playbook_name = demisto.args()['playbook_name']
        attacker_ip = demisto.args()['attacker_ip']
        playbook_id = None
        playbook_status = None
        login_status = attivo_api.login(API_USER, API_PASS)
        all_playbooks = attivo_api.get_playbooks()
        for playbook in all_playbooks['pb']:
            if playbook['name'] == playbook_name:
                playbook_id = playbook['id']
                break

        if not playbook_id:
            demisto.error("ID not found for Attivo playbook named: {}".format(playbook_name))
            status_message = "Failed: could not find playbook named '{}'".format(playbook_name)
            status = False
        else:
            demisto.info("Running Attivo playbook named {} ({}) with attacker IP {}".format(playbook_name, playbook_id, attacker_ip))
            playbook_status = attivo_api.run_playbook(playbook_id, attacker_ip)
            demisto.info("Run playbook status = {}".format(playbook_status))

            if playbook_status['status']:
                status_text = playbook_status['status']
                if status_text == 'submitted':
                    status=True
                    status_message = "Attivo playbook '{}' (ID={}) has been run with attacker IP {}".format(playbook_name, playbook_id,attacker_ip)
                else:
                    status=False
                    status_message = "Attivo playbook has not been run.  Status = '{}'".format(status_text)
            else:
                status = False
                status_message = "Attivo playbook has not been run.  Status = 'Unknown failure'"

        entry = {
            'Type': entryTypes['note'],
            'Contents': playbook_status,
            'ContentsFormat': formats['json'],
            'HumanReadable': status_message,
            'ReadableContentsFormat': formats['text'],
            'EntryContext': {'Attivo.Playbook.Status': status,
                             'Attivo.Playbook.Message': status_message}
            }

        demisto.results(entry)
        logout_status = attivo_api.logout()

    if demisto.command() == 'attivo-deploy-decoy':
        vulnerable_ip = demisto.args()['vulnerable_ip']
        decoy_number = demisto.args()['decoy_number']
        login_status = attivo_api.login(API_USER, API_PASS)
        demisto.info("Deploying {} decoy(s) on the subnet of {}".format(decoy_number, vulnerable_ip))
        deploy_status = {}
        deploy_status = attivo_api.deploy_decoys(vulnerable_ip,decoy_number=decoy_number)
        demisto.info("Deployment status = {}".format(deploy_status))

        status = False
        status_text = "Unknown failure"
        if 'result' in deploy_status:
            status_text = deploy_status['result'][0]['success']
            if status_text == True:
                status = True
        elif 'success' in deploy_status:
            status_text = deploy_status['success']
            if status_text == True:
                status = True
        elif 'error' in deploy_status:
            status_text = deploy_status['error']

        if status:
            status_message = "{} new Attivo decoy(s) deployed on the subnet with {}".format(decoy_number,vulnerable_ip)
        else:
            status_message = "No Attivo decoys have been deployed. {}".format(status_text)

        entry = {
            'Type': entryTypes['note'],
            'Contents': deploy_status,
            'ContentsFormat': formats['json'],
            'HumanReadable': status_message,
            'ReadableContentsFormat': formats['text'],
            'EntryContext': {'Attivo.DeployDecoy.Status': status,
                             'Attivo.DeployDecoy.Message': status_message}
            }

        demisto.results(entry)
        logout_status = attivo_api.logout()

    if demisto.command() == 'attivo-list-users':
        demisto.info("Retrieving information about all deceptive users")
        login_status = attivo_api.login(API_USER, API_PASS)

        user_groups = attivo_api.get_deceptive_objects('USERS','ALL')
        users = {}
        for user_group in user_groups['objGroup']:
            group_id = user_group['esid']
            group_name = user_group['name']
            users_in_group = attivo_api.get_deceptive_objects('USERS', group_id)
            for user_object in users_in_group['objGroup']['objects']:
                user = user_object['username']
                if user in users:
                    users[user].append(group_name)
                else:
                    users[user] = [group_name]

        all_users = []
        for user in sorted(users.keys(), key=lambda x: x.lower()):
            user_entry = {'User': user, 'Groups': ", ".join(users[user])}
            all_users.append(user_entry)

        headers = ['User', 'Groups']
        entry = {
            'Type': entryTypes['note'],
            'Contents': all_users,
            'ContentsFormat': formats['json'],
            'HumanReadable': tableToMarkdown('Attivo deceptive users', all_users, headers=headers),
            'ReadableContentsFormat': formats['markdown'],
            'EntryContext': {}
        }

        demisto.results(entry)
        logout_status = attivo_api.logout()


    if demisto.command() == 'attivo-check-user':
        user = demisto.args()['user']
        demisto.info("Check Attivo for user = {}".format(user))
        login_status = attivo_api.login(API_USER, API_PASS)

        is_deceptive = False
        this_user_object= None

        user_groups = attivo_api.get_deceptive_objects('USERS','ALL')
        in_groups = []
        for user_group in user_groups['objGroup']:
            group_id = user_group['esid']
            users_in_group = attivo_api.get_deceptive_objects('USERS', group_id)
            for user_object in users_in_group['objGroup']['objects']:
                this_user = user_object['username']
                if this_user == user:
                    this_user_object = user_object
                    is_deceptive = True
                    in_groups.append(user_group['name'])
                    break

        output_table = {'User': user, 'Is Deceptive': str(is_deceptive), 'Groups': ', '.join(in_groups)}

        entry = {'Type': entryTypes['note'],
                'Contents': this_user_object,
                'ContentsFormat': formats['text'],
                'HumanReadable': output_table,
                'ReadableContentsFormat': formats['table'],
                'EntryContext': {
                                    'Attivo.User.Name': user,
                                    'Attivo.User.IsDeceptive': is_deceptive,
                                    'Attivo.User.Groups': in_groups
                                 }
        }

        demisto.info("User {user}, deceptive = {is_deceptive}, group(s) = {groups}".format(user=user,is_deceptive=is_deceptive, groups=in_groups))
        demisto.results(entry)
        logout_status = attivo_api.logout()

    if demisto.command() == 'attivo-list-hosts':
        demisto.info('Retrieving information about all deceptive hosts')
        login_status = attivo_api.login(API_USER, API_PASS)

        all_hosts=[]

        td_monitoring = attivo_api.get_threatdirect_rules()
        bs_monitoring = attivo_api.get_monitoring_rules()

        if td_monitoring['forwarder_vm_monitoring_rules']['forwarderVmMonitoringRules']:
            for rule in td_monitoring['forwarder_vm_monitoring_rules']['forwarderVmMonitoringRules']:
                if rule['type'] == 'onNet':
                    td_type = "EP"
                else:
                    td_type = "VM"

                host_names = []
                if 'dnsName' in rule and rule['dnsName']:
                    host_names.append(rule['dnsName'])

                host_entry = {  'IP': rule['ip'],
                                'MAC': rule['customized_mac'],
                                'VLAN': rule['vlanID'],
                                'DHCP': rule['dhcpip'],
                                'TD Name': rule['threatDirectName'],
                                'TD Type': td_type,
                                'Host Name': ', '.join(host_names)
                            }
                all_hosts.append(host_entry)

        if bs_monitoring['cfg_monitoring_rules']['monitoringRules']:
            for rule in bs_monitoring['cfg_monitoring_rules']['monitoringRules']:
                #demisto.info("BS RULE: {}".format(rule))
                vlan = rule['vlanID']
                if vlan == -1:
                    vlan = None

                host_names = []
                if 'dnsName' in rule and rule['dnsName']:
                    host_names.append(rule['dnsName'])
                if 'interfaceName' in rule and rule['interfaceName']:
                    host_names.append(rule['interfaceName'])

                host_entry = {  'IP': rule['ipAddress'],
                            'MAC': rule['externalMAC'],
                            'DHCP': rule['isDHCPIP'],
                            'VLAN': vlan,
                            'User Defined': rule['userDefined'],
                            'Host Name': ", ".join(host_names)
                        }
                if td_monitoring is not None:
                    host_entry['TD Name'] = ''
                    host_entry['TD Type'] = ''
                all_hosts.append(host_entry)

        headers = ['IP', 'Host Name', 'MAC', 'VLAN', 'DHCP']

        if td_monitoring['forwarder_vm_monitoring_rules']['forwarderVmMonitoringRules']:
            headers.append('TD Name')
            headers.append('TD Type')

        entry = {
            'Type': entryTypes['note'],
            'Contents': all_hosts,
            'ContentsFormat': formats['json'],
            'HumanReadable': tableToMarkdown("Attivo deceptive hosts (network decoys): {}".format(len(all_hosts)), all_hosts, headers=headers),
            'ReadableContentsFormat': formats['markdown'],
            'EntryContext': {}
        }

        demisto.results(entry)
        logout_status = attivo_api.logout()


    if demisto.command() == 'attivo-check-host':
        host = demisto.args()['host']
        demisto.info("Check Attivo for host = {}".format(host))
        login_status = attivo_api.login(API_USER, API_PASS)

        is_deceptive = False
        this_rule = None
        host_info={}

        if valid_ip(host):
            ip_address = host
            host_name = None
        else:
            host_name = host
            ip_address = None

        # Check native Monitoring Rules
        bs_monitoring = attivo_api.get_monitoring_rules()
        if bs_monitoring is not None:
            for rule in bs_monitoring['cfg_monitoring_rules']['monitoringRules']:
                this_ip = rule['ipAddress']
                mac = rule['externalMAC']
                dhcp = rule['isDHCPIP']
                vlan = rule['vlanID']
                if vlan == -1:
                    vlan = None
                user_defined = rule['userDefined']
                this_host_name = []
                if 'dnsName' in rule and rule['dnsName']:
                    this_host_name.append(rule['dnsName'])
                if 'interfaceName' in rule and rule['interfaceName']:
                    this_host_name.append(rule['interfaceName'])

                if (ip_address and this_ip == ip_address) or (host_name and this_host_name and host_name in this_host_name):
                    this_rule = rule
                    is_deceptive = True
                    demisto.info("Attivo BOTSink IP/Host match ({ip}) ({name}) ({user_defined}) ({mac}) ({dhcp}) ({vlan})".format(ip=this_ip, name=this_host_name, user_defined=user_defined, mac=mac, dhcp=dhcp, vlan=vlan))
                    host_info = {'ip': this_ip, 'name': this_host_name, 'user_defined': user_defined, 'mac': mac, 'dhcp': dhcp, 'vlan': vlan}
                    break


        if not is_deceptive:
            # Check ThreatDirect Monitoring Rules
            td_monitoring = attivo_api.get_threatdirect_rules()
            if td_monitoring is not None:
                for rule in td_monitoring['forwarder_vm_monitoring_rules']['forwarderVmMonitoringRules']:
                    this_ip = rule['ip']
                    this_host_name = []
                    mac = rule['customized_mac']
                    vlan = rule['vlanID']
                    dhcp = rule['dhcpip']
                    td_name = rule['threatDirectName']
                    if rule['type'] == 'onNet':
                        td_type = "EP"
                    else:
                        td_type = "VM"
                    if 'dnsName' in rule and rule['dnsName']:
                        this_host_name.append(rule['dnsName'])

                    if (ip_address and this_ip == ip_address) or (host_name and this_host_name and host_name in this_host_name):
                        this_rule = rule
                        is_deceptive = True
                        demisto.info("Attivo ThreatDirect IP match ({ip}) ({name}) ({mac}) ({dhcp}) ({vlan}) ({td_name}) ({td_type})".format(ip=this_ip, name=this_host_name, mac=mac, dhcp=dhcp, vlan=vlan, td_name=td_name, td_type=td_type))
                        host_info = {'ip': this_ip, 'name': this_host_name, 'mac': mac, 'dhcp': dhcp, 'vlan': vlan, 'td_name': td_name, 'td_type': td_type}
                        break
                    #elif host_name and this_host_name and host_name in this_host_name:
                     #   this_rule = rule
                     #   is_deceptive = True
                     #   demisto.info("Attivo ThreatDirect host match ({ip}) ({name}) ({user_defined}) ({mac}) ({dhcp}) ({vlan})".format(this_ip, #this_host_name, user_defined, mac, dhcp, vlan))
                    #break

        if is_deceptive:
            output_table = {'Is Deceptive': 'True',
                'IP Address': this_ip,
                'Host Names': ', '.join(this_host_name),
                'MAC Address': mac,
                'DHCP': str(dhcp),
                'User Defined': str(user_defined),
                'VLAN': vlan
            }
        else:
            output_table = {'Is Deceptive': 'False',
                'IP Address': ip_address,
                'Host Names': host_name,
                'MAC Address': '',
                'DHCP': '',
                'User Defined': '',
                'VLAN': ''
            }


        entry = {'Type': entryTypes['note'],
                'Contents': output_table,
                'ContentsFormat': formats['table'],
                'HumanReadable': output_table,
                'ReadableContentsFormat': formats['table'],
                'EntryContext': {'Attivo.Host.HostInfo': host_info,
                                 'Attivo.Host.IsDeceptive': is_deceptive
                                }
                }

        demisto.info("Deception status for {host} is {is_deceptive}".format(host=host,is_deceptive=is_deceptive))
        demisto.results(entry)
        logout_status = attivo_api.logout()
  type: python
  commands:
  - name: attivo-check-user
    arguments:
    - name: user
      required: true
      description: User to validate
    outputs:
    - contextPath: Attivo.User.IsDeceptive
      description: Is the user part of the Deception environment
      type: boolean
    - contextPath: Attivo.User.Groups
      description: If the user is part of the Deception environment, it is a member
        of these groups
    description: Check whether a user is deceptive
  - name: attivo-check-host
    arguments:
    - name: host
      required: true
      default: true
      description: Host name or IP to validate
    outputs:
    - contextPath: Attivo.Host.IsDeceptive
      description: Is the IP or hostname part of the Decpetion environment
      type: boolean
    - contextPath: Attivo.Host.IPAddress
      description: IP Address of deceptive host
    - contextPath: Attivo.Host.Name
      description: Hostname of deceptive host
    - contextPath: Attivo.Host.MACAddress
      description: MAC Address of deceptive host
    - contextPath: Attivo.Host.VLAN
      description: VLAN of deceptive host
    - contextPath: Attivo.Host.UserDefined
      description: Was this host manually defined
      type: boolean
    - contextPath: Attivo.Host.DHCP
      description: Does the host have a dynamic IP address
      type: boolean
    - contextPath: Attivo.Host.ThreatDirect.Name
      description: Name of the ThreatDirect device projecting this deceptive host
    - contextPath: Attivo.Host.ThreatDirect.Type
      description: The type of ThreatDirect device projecting the deceptive host
    description: Check whether a host is deceptive
  - name: attivo-run-playbook
    arguments:
    - name: playbook_name
      required: true
      description: The name of the prebuilt playbook
    - name: attacker_ip
      required: true
      description: Malicious source IP
    outputs:
    - contextPath: Attivo.Playbook.Message
      description: Complete status message
      type: string
    - contextPath: Attivo.Playbook.Status
      description: Success or failure boolean
      type: boolean
    description: Run a pre-built playbook on the BOTsink appliance
  - name: attivo-deploy-decoy
    arguments:
    - name: vulnerable_ip
      required: true
      description: Used to determine which subnet to deploy to
    - name: decoy_number
      default: true
      description: The number of decoys to deploy
      defaultValue: "1"
    outputs:
    - contextPath: Attivo.DeployDecoy.Status
      description: Success or failure boolean
      type: boolean
    - contextPath: Attivo.DeployDecoy.Message
      description: Complete status message
      type: string
    description: 'Deploy a new network decoy '
  - name: attivo-get-events
    arguments:
    - name: attacker_ip
      required: true
      description: Source IP
    - name: severity
      auto: PREDEFINED
      predefined:
      - VeryHigh
      - High
      - Medium
      - Low
      - VeryLow
      - SystemActivity
      description: The minimum Attivo severity
      defaultValue: Medium
    - name: alerts_start_date
      description: Timeframe to start looking for events. For example,  2018-12-10
        or 2018-12-10T13:59:05Z
    - name: alerts_end_date
      description: Timeframe to stop looking for events. For example,  2018-12-10
        or 2018-12-10T13:59:05Z
    outputs:
    - contextPath: Attivo.Events.Count
      description: Total number of events retrieved
      type: number
    - contextPath: Attivo.Events.List.Attack Name
      description: Short name of the attack
    - contextPath: Attivo.Events.List.Attack Phase
      description: Kill chain phase of hte attack
      type: string
    - contextPath: Attivo.Events.List.Server
      description: Internal name for target decoy
      type: string
    - contextPath: Attivo.Events.List.Targert
      description: External name for target decoy
      type: string
    - contextPath: Attivo.Events.List.Target OS
      description: Operating system of target decoy
      type: string
    - contextPath: Attivo.Events.List.Attacker
      description: Attacker IP address
      type: string
    - contextPath: Attivo.Events.List.Service
      description: The attacked service
      type: string
    - contextPath: Attivo.Events.List.Timestamp
      description: Time of the attack
      type: string
    - contextPath: Attivo.Events.List.Target IP
      description: IP address of the target decoy
      type: string
    - contextPath: Attivo.Events.List.Severity
      description: Attivo severity of the attack
      type: string
    description: Retrieve events for a specific source IP
  - name: attivo-list-playbooks
    arguments: []
    description: List information about playbooks configured on the Attivo device
  - name: attivo-list-hosts
    arguments: []
    description: List information about network decoys
  - name: attivo-list-users
    arguments: []
    description: List all deceptive users
  isfetch: true
  runonce: false
releaseNotes: new integration
tests:
  - AttivoBotsinkTest