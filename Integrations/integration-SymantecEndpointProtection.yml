commonfields:
  id: Symantec Endpoint Protection
  version: -1
name: Symantec Endpoint Protection
display: Symantec Endpoint Protection
category: Endpoint
image: data:image/png;base64,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
description: Query the Symantec Endpoint Protection Manager using the official REST
  API.
detaileddescription: Integration with Symantec Endpoint Protection Manager using the
  sepm REST API.
configuration:
- display: Server (e.g. https://1.2.3.4:8446)
  name: server
  defaultvalue: ""
  type: 0
  required: true
- display: Authentication
  name: authentication
  defaultvalue: ""
  type: 9
  required: true
- display: SEPM domain for the user
  name: domain
  defaultvalue: ""
  type: 0
  required: false
- display: Trust any certificate (unsecure)
  name: insecure
  defaultvalue: "false"
  type: 8
  required: false
- display: Use proxy system settings
  name: proxy
  defaultvalue: "true"
  type: 8
  required: false
- display: 'Local time zone (for example: +02:30,-06:00)'
  name: timeZone
  defaultvalue: ""
  type: 0
  required: false
script:
  script: |+
    import requests
    import json
    import re
    requests.packages.urllib3.disable_warnings()

    if not demisto.params()['proxy']:
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']

    # Default timeout and interval parameters for polling the response
    CLIENT_COMMAND_PARAMETERS = {
        'sep-update-content'    : {'timeout': 120, 'interval': 10},
        'sep-quarantine'        : {'timeout': 120, 'interval': 10},
        #  Don't poll for scan response because it takes too long. The automation will do that
        'sep-scan'              : {'timeout': 1, 'interval': 1}
    }

    ENDPOINTS_INFO_DEFAULT_COLUMNS = [
        'computerName',
        'ipAddresses',
        'operatingSystem',
        'osBitness',
        'cidsDefsetVersion',
        'lastScanTime',
        'description',
        'quarantineDesc',
        'domainOrWorkgroup',
        'macAddresses',
        'group',
        'dhcpServer',
        'biosVersion',
        'virtualizationPlatform',
        'computerTimeStamp',
        'creationTime',
        'agentTimestamp'
    ]

    GROUPS_INFO_DEFAULT_COLUMNS = [
        'fullPathName',
        'numberOfPhysicalComputers',
        'numberOfRegisteredUsers',
        'policySerialNumber',
        'policyDate',
        'description',
        'created',
        'id'
    ]

    # @@@@@@@@@@@@@@@@@@@@@@@@@@    LITERALS    @@@@@@@@@@@@@@@@@@@@@@@@@@

    TOKEN = demisto.getIntegrationContext().get('TOKEN')
    EPOCH_MINUTE = 60 * 1000
    EPOCH_HOUR = 60 * EPOCH_MINUTE

    # @@@@@@@@@@@@@@@@@@@@@@@@@@    HELPER FUNCTIONS    @@@@@@@@@@@@@@@@@@@@@@@@@@

    def fix_url(base):
        return (base if base.endswith('/') else (base + '/'))


    def build_query_params(params):
        list_params = map(lambda key: key + '=' + str(params[key]), params.keys())
        quert_params = '&'.join(list_params)
        return '?' + quert_params if quert_params else ''


    def do_auth(server, crads, insecure):
        url = fix_url(str(server)) + 'sepm/api/v1/identity/authenticate'
        body = {
            'username': crads.get('identifier') if crads.get('identifier') else '',
            'password': crads.get('password') if crads.get('password') else '',
            'domain': crads.get('domain') if crads.get('domain') else ''
        }
        res = requests.post(url, headers={"Content-Type":"application/json"}, data=json.dumps(body), verify=not insecure)
        return parse_response(res)


    def do_get(token, raw, suffix):
        insecure = demisto.getParam('insecure')
        server = demisto.getParam('server')
        url = fix_url(server) + suffix
        res = requests.get(url, headers={'Authorization': 'Bearer ' + token}, verify=not insecure)
        if (raw):
            return res
        else:
            return parse_response(res)


    def do_post(token, is_xml, suffix, body):
        insecure = demisto.getParam('insecure')
        server = demisto.getParam('server')
        url = fix_url(server) + suffix
        res = requests.post(url, headers = {'Authorization': 'Bearer ' + token}, data=body, verify = not insecure)
        if (is_xml):
            parsed_response = xml2json(res.content)
        else:
            parsed_response = parse_response(res)
        return parsed_response


    def do_put(token, suffix, body):
        insecure = demisto.getParam('insecure')
        server = demisto.getParam('server')
        url = fix_url(server) + suffix
        res = requests.put(url, headers = {'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json'}, data=json.dumps(body), verify = not insecure)
        # res = requests.put('https://httpbin.org/put', headers = {'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json'}, data=json.dumps(body), verify = not insecure)
        parsed_response = parse_response(res)
        return parsed_response


    def parse_response(resp):
        if resp.status_code == 200:
            if resp.text == '':
                return resp
            try:
                return resp.json()
            except Exception, ex:
                return_error('Unable to parse response: {}'.format(ex))
        else:
            try:
                message = resp.json().get('errorMessage')
                return_error('Error: {}'.format(message))
            except Exception:
                return_error('Error: {}'.format(resp))


    def get_token_from_response(resp):
        if resp.get('token'):
            return resp.get('token')
        else:
            return_error('No token: {}'.format(resp))


    def choose_columns(column_arg, default_list):
        if not column_arg:
            columns_list = default_list
            columns_list.sort()
        elif column_arg == 'all' or column_arg =='*':
            columns_list = []
        else:
            columns_list = argToList(column_arg)
        return columns_list


    def build_command_xml(data):
        return '<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:com="http://command.client.webservice.sepm.symantec.com/"> \
                <soapenv:Header/><soapenv:Body>{0}</soapenv:Body></soapenv:Envelope>'.format(data)

    def build_client_xml(data):
        return '<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:cli="http://client.webservice.sepm.symantec.com/"> \
                <soapenv:Header/><soapenv:Body>{0}</soapenv:Body></soapenv:Envelope>'.format(data)


    def get_command_status_details(token, command_id):
        xml = build_command_xml('<com:getCommandStatusDetails><commandID>{0}</commandID></com:getCommandStatusDetails>'.format(command_id))
        res_json = do_post(token, True, 'sepm/ws/v1/CommandService', xml)

        return res_json


    def poll_response(token, command_id, timeout, interval):
        retries = timeout / interval
        is_done = False
        for _ in range(retries):
            command_status_json = get_command_status_details(token, command_id)
            cmd_status_detail = demisto.get(json.loads(command_status_json), 'Envelope.Body.getCommandStatusDetailsResponse.CommandStatusDetailResult.cmdStatusDetail')
            state_id = cmd_status_detail.get('stateId')
            if state_id == '2' or state_id == '3':
                is_done = True
                break
            time.sleep(interval)

        return {
            'cmdStatusDetail': cmd_status_detail,
            'isDone': is_done
        }


    def build_command_response_output(title, command_id, message, response):
        cmd_status_details = response.get('cmdStatusDetail')
        cmd_status_details.pop('hardwareKey',None)

        md = tableToMarkdown(title, cmd_status_details) + '\n'
        md += '### Command ID: {0}\n'.format(command_id)
        md += '### ' + message;

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': {
                'cmdStatusDetail': cmd_status_details,
                'commandId': command_id

            },
            'HumanReadable': md,
            'EntryContext': {
                'SEPM.LastCommand': createContext({'CommandDetails': cmd_status_details,'CommandId': command_id}, removeNull = True)
            }
        })

    def get_computer_id_by_ip(token, ip):
        xml = build_client_xml('<cli:getComputersByIP><ipAddresses>{0}</ipAddresses></cli:getComputersByIP>'.format(ip))
        res_json = do_post(token, True, 'sepm/ws/v1/ClientService', xml)

        return demisto.get(json.loads(res_json) ,'Envelope.Body.getComputersByIPResponse.ComputerResult.computers.computerId')


    def get_computer_id_by_hostname(token, hostname):
        xml = build_command_xml('<cli:getComputersByHostName><computerHostNames>{0}</computerHostNames></cli:getComputersByHostName>'.format(hostname))
        res_json = do_post(token, True, 'sepm/ws/v1/ClientService', xml)

        return demisto.get(json.loads(res_son), 'resJson.Envelope.Body.getComputersByHostNameResponse.ComputerResult.computers.computerId')

    def get_computer_id(token, endpoint_ip, endpoint_host_name):
        if endpoint_ip:
            try:
                computer_id = get_computer_id_by_ip(token, endpoint_ip)
            except Exception, ex:
                return_error('Failed to locate the endpoint by its IP address.')
        elif endpoint_host_name:
            try:
                computer_id = get_computer_id_by_hostname(token, endpoint_ip)
            except Exception, ex:
                return_error('Failed to locat the endpoint by its hostname.')
        else:
            return_error('Please provide the IP address or the hostname of endpoint.')
        return computer_id


    def update_content(token, computer_id):
        xml = build_command_xml('<com:runClientCommandUpdateContent><computerGUIDList>{0}</computerGUIDList></com:runClientCommandUpdateContent>'.format(computer_id))
        res_json = do_post(token, True, 'sepm/ws/v1/CommandService', xml)
        command_id = demisto.get(json.loads(res_json), 'Envelope.Body.runClientCommandUpdateContentResponse.CommandClientResult.commandId')

        if not command_id:
            error_code = demisto.get(res_json, 'Envelope.Body.runClientCommandUpdateContentResponse.CommandClientResult.inputErrors.errorCode')
            error_message = demisto.get(res_json, 'Envelope.Body.runClientCommandUpdateContentResponse.CommandClientResult.inputErrors.errorMessage')
            if error_code or error_message:
                return_error('An error response has returned from server: {0} with code: {1}'.format(errorMessage, errorCode))
            else:
                return_error('Could not retrieve command ID, no error was returned from server')
        return command_id


    def scan (token, computer_id, scan_type):
        xml = build_command_xml('<com:runClientCommandScan><computerGUIDList>{0}</computerGUIDList><scanType>{1}</scanType></com:runClientCommandScan>'.format(computer_id, scan_type))
        res_json = do_post(token, True, 'sepm/ws/v1/CommandService', xml)
        command_id = demisto.get(json.loads(res_json), 'Envelope.Body.runClientCommandScanResponse.CommandClientResult.commandId')

        if not command_id:
            error_code = demisto.get(json.loads(res_json), 'Envelope.Body.runClientCommandScanResponse.CommandClientResult.inputErrors.errorCode')
            error_message = demisto.get(json.loads(res_json), 'Envelope.Body.runClientCommandScanResponse.CommandClientResult.inputErrors.errorMessage')
            if error_code or error_message:
                return_error('An error response has returned from server: {0} with code: {1}'.format(errorMessage, errorCode))
            else:
                return_error('Could not retrieve command ID, no error was returned from server')
        return command_id


    def quarantine(token, computer_id, action_type):
        xml = build_command_xml('<com:runClientCommandQuarantine><command><commandType>{0}</commandType><targetObjectIds>{1}</targetObjectIds><targetObjectType>COMPUTER</targetObjectType></command></com:runClientCommandQuarantine>'.format(action_type, computer_id));
        res_json = do_post(token, True, 'sepm/ws/v1/CommandService', xml);
        command_id = demisto.get(json.loads(res_json), 'Envelope.Body.runClientCommandQuarantineResponse.CommandClientResult.commandId')
        if not command_id:
            error_code = demisto.get(res_json, 'Envelope.Body.runClientCommandQuarantineResponse.CommandClientResult.inputErrors.errorCode')
            error_message = demisto.get(res_json, 'Envelope.Body.runClientCommandQuarantineResponse.CommandClientResult.inputErrors.errorMessage')
            if error_code or error_message:
                return_error('An error response has returned from server: {0} with code: {1}'.format(errorMessage, errorCode))
            else:
                return_error('Could not retrieve command ID, no error was returned from server')
        return command_id


    def validate_time_zone(time_zone):
        pattern = re.compile("^[+-][0-9][0-9]:[0-9][0-9]")
        return bool(pattern.match(time_zone))


    def parse_epoch_to_local(epoch, time_zone):
        if not validate_time_zone(time_zone):
            return_error('timeZone param should be in the format of [+/-][h][h]:[m][m]. For exmaple +04:30')
        operator = time_zone[0]
        hour = int(time_zone[1:3])
        minutes = int(time_zone[4:6])
        time_zone_epoch = hour * EPOCH_HOUR + minutes * EPOCH_MINUTE
        local = int(epoch) + time_zone_epoch if operator == '+' else int(epoch) - time_zone_epoch
        return local


    def change_assigined(policy):
        new_format = {
           'Policy Name': policy.get('PolicyName'),
           'Type': policy.get('Type'),
           'ID': policy.get('ID'),
           'Assigned': True if (policy.get('AssignedLocations') or policy.get('AssignedCloudGroups')) else False,
           'Discription': policy.get('Discription'),
           'Enabled': policy.get('Enabled')
        }
        return new_format


    def sanitize_policies_list_for_md(policies_list):
        return map(change_assigined, policies_list)


    def sanitize_policies_list(policies_list):
        return map(lambda policy: {
            'PolicyName': policy['name'],
            'Type': policy['policytype'],
            'ID': policy['id'],
            'Discription': policy['desc'],
            'Enabled': policy['enabled'],
            'AssignedLocations': map(lambda location:{
               'GroupID': location.get('groupId'),
               'Locations': location.get('locationIds')
            }, policy.get('assignedtolocations') if policy.get('assignedtolocations') else []),
            'AssignedCloudGroups': map(lambda location:{
              'GroupID': location.get('groupId'),
              'Locations': location.get('locationIds')
            }, policy.get('assignedtocloudgroups') if policy.get('assignedtocloudgroups') else []),
        }, policies_list)


    def validate_ip(ip):
        pattern = re.compile('^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$')
        return bool(pattern.match(ip))


    # @@@@@@@@@@@@@@@@@@@@@@@@@@    COMMANDS    @@@@@@@@@@@@@@@@@@@@@@@@@@


    def system_info_command(token):

        insecure = demisto.getParam('insecure')
        version_json = do_get(token, False, 'sepm/api/v1/version')
        avdef_json = do_get(token, False, 'sepm/api/v1/content/avdef/latest')
        system_info_json = {
            'version': version_json,
            'avdef': avdef_json
        }

        md = '## System Information\n'
        md += tableToMarkdown('Version', version_json)
        md += tableToMarkdown('AV Definitions', avdef_json)

        context = avdef_json.get('publishedBySymantec')
        if(type(context) is dict):
            context = createContext(context, removeNull = True)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': system_info_json,
            'HumanReadable': md,
            'EntryContext': {
                'SEPM.ServerAVDefVersion': context
            }
        })


    def client_content_command(token):
        time_zone = demisto.getParam('timeZone')
        client_content_json = do_get(token, False, 'sepm/api/v1/stats/client/content')
        epoch_time = client_content_json.get('lastUpdated')
        if time_zone:
            epoch_time = parse_epoch_to_local(epoch_time, time_zone)
        # epoch_time = '1546185294597'
        # last_update_date = time.localtime(int(epoch_time) /1000)
        last_update_date = timestamp_to_datestring(epoch_time, '%a %b %d %y %H:%M:%S %z')

        md = '## Client Content, last updated on {0}\n'.format(last_update_date)
        md += tableToMarkdown('Client Content Versions', client_content_json.get('clientDefStatusList'))

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': client_content_json,
            'HumanReadable': md,
            'EntryContext': createContext({'SEPM.ClientContentVersions': client_content_json.get('clientDefStatusList'),'SEPM.LastUpdated': last_update_date}, removeNull = True)
        })


    def endpoints_info_command(token):
        computer_name = demisto.getArg('computerName')
        last_update = demisto.getArg('lastUpdate')
        os = demisto.getArg('os')
        page_size = demisto.getArg('pageSize')
        columns = demisto.getArg('columns')

        json_response = do_get(token, False, 'sepm/api/v1/computers' + build_query_params(demisto.args()))

        md = '## Endpoints Information'
        md += ', filtered for last updated status: {}'.format(last_update) if last_update else ''
        md += ', filtered for hostname: {}'.format(computer_name) if computer_name else ''
        md += ', filtered for os: {}'.format(os) if os else ''
        md += ', page size: {}'.format(page_size) if page_size else ''
        md += '\n'

        entry_context = []
        filtered_json_response = json_response.get('content')
        for content in filtered_json_response:
            entry_context.append({
                'Hostname': content.get('computerName'),
                'Domain': content.get('domainOrWorkgroup'),
                'IPAddresses': content.get('ipAddresses'),
                'OS': content.get('operatingSystem') + ' | ' + content.get('osBitness'),
                'Description': content.get('content.description'),
                'MACAddresses': content.get('macAddresses'),
                'BIOSVersion': content.get('biosVersion'),
                'DHCPServer': content.get('dhcpServer')
            })

        columns_list = choose_columns(columns, ENDPOINTS_INFO_DEFAULT_COLUMNS)

        md += tableToMarkdown('Endpoints', filtered_json_response, columns_list)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': filtered_json_response,
            'HumanReadable': md,
            'EntryContext': {
                'SEPM.Endpoint(val.computerName == obj.computerName)': createContext(entry_context, removeNull = True)
            }
        })


    def groups_info_command(token):
        columns = demisto.getArg('columns')
        json_res = do_get(token, False, 'sepm/api/v1/groups' + build_query_params(demisto.args()))
        entry_context = {}
        entry_context['SEPM.Groups'] = []
        filtered_json_response = json_res.get('content')
        for entry in filtered_json_response:
            group = {}
            for header in GROUPS_INFO_DEFAULT_COLUMNS:
                group[header] = entry[header]
            entry_context['SEPM.Groups'].append(group)
        deafult_headers = GROUPS_INFO_DEFAULT_COLUMNS
        deafult_headers.remove('id')
        columns_list = choose_columns(columns, deafult_headers)

        md = tableToMarkdown('Groups Information', filtered_json_response, columns_list)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': json_res,
            'HumanReadable': md,
            'EntryContext': createContext(entry_context, removeNull = True)

        })

    def command_status(token):
        # Poll once for a response (timeout=1, interval=1)
        command_id = demisto.getArg('commandId')
        response = poll_response(token, command_id, 1, 1)
        message = 'Command is done.' if response.get('isDone') else 'Command is in progress. Run !sep-command-status to check again.';

        return build_command_response_output('Command status:', command_id, message, response)



    def run_client_command(token, command):
        endpoint_ip = demisto.getArg('ip')
        endpoint_host_name = demisto.getArg('hostname')
        try:
            computer_id = get_computer_id(token, endpoint_ip, endpoint_host_name)
            timeout = int(demisto.getParam('timeout')) if demisto.getParam('timeout') else CLIENT_COMMAND_PARAMETERS[command]['timeout']
            interval = int(demisto.getParam('interval')) if demisto.getParam('interval') else CLIENT_COMMAND_PARAMETERS[command]['interval']

        except Exception, ex:
            return_error('unable to run command: {}'.format(ex))

        if command == 'sep-update-content':
            command_id = update_content(token, computer_id)
        elif command == 'sep-scan':
            scan_type = demisto.getArg('scanType')
            command_id = scan(token, computer_id, scan_type)
        elif command == 'sep-quarantine':
            action_type = demisto.getArg('actionType')
            command_id = quarantine(token, computer_id, action_type)

        response = poll_response(token, command_id, timeout, interval)
        endpoint = endpoint_ip if endpoint_ip else endpoint_host_name
        title = 'Launched {0} command for endpoint {1}, here is the output.\n'.format(command, endpoint)

        if response.get('isDone'):

            message = 'Command is done.'
        elif command == 'sep-scan':
            message = 'Command is in progress.'
        else:
            message = 'Command timed out after {0} second(s). Run !sep-command-status to check again.'.format(timeout)

        return build_command_response_output(title, command_id, message, response)


    def list_policies_command(token):
        policies_list = do_get(token, False, 'sepm/api/v1/policies/summary').get('content')

        fixed_policie_list = sanitize_policies_list(policies_list)
        md_list = sanitize_policies_list_for_md(fixed_policie_list)
        md = tableToMarkdown('List of existing policies', md_list, ['Policy Name', 'Type', 'ID', 'Enabled', 'Assigned', 'Discription' ])
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': policies_list,
            'HumanReadable': md,
            'EntryContext': {
                'SEPM.PoliciesList': createContext(fixed_policie_list, removeNull = True)
            }
        })


    def assign_policie_command(token):
        group_id = demisto.getArg('groupID')
        locatoion_id = demisto.getArg('locationID')
        policy_type = demisto.getArg('policyType').lower()
        policy_id = demisto.getArg('policyID')
        resp = do_put(token, 'sepm/api/v1/groups/{0}/locations/{1}/policies/{2}'.format(group_id, locatoion_id, policy_type), {'id': policy_id})
        md = '### Policy: {0}, of type: {1}, was assigned to location: {2}, in group: {3}'.format(policy_id, policy_type, locatoion_id, group_id)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': '',
            'HumanReadable': md,
            'EntryContext': {}
        })


    def list_locations_command(token):
        group_id = demisto.getArg('groupID')
        url = 'sepm/api/v1/groups/{}/locations'.format(group_id)
        url_resp = do_get(token, False, url)
        location_ids = map(lambda location_string: {'ID' : location_string.split('/')[-1]}, url_resp)
        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': url_resp,
            'HumanReadable': tableToMarkdown('Locations', map(lambda location: {'Location ID' : location.get('id')} , location_ids)),
            'EntryContext': {
                'SEPM.Locations': location_ids
            }
        })

    def endpoint_quarantine_command(token):
        endpoint = demisto.getArg('endpoint')
        action = demisto.getArg('actionType')
        action_type = 'Quarantine' if action == 'Add' else 'Undo'

        if not endpoint:
            return_error('Please provide the IP address or the hostname of endpoint.')
        elif validate_ip(endpoint):
            computer_id = get_computer_id(token, endpoint, None)
        else:
            computer_id = get_computer_id(token, None, endpoint)
        command_id = quarantine(token, computer_id, action_type)
        message = '### Initiated quarantine for endpoint {0}. Command ID: {1}.'.format(endpoint, command_id) if action == 'Add' else '### Removing endpoint: {0} from quarantine. Command ID: {1}.'.format(endpoint, command_id)
        context = {
            'CommandID': command_id,
            'Action' : action,
            'Endpoint' : endpoint
        }

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['text'],
            'Contents': command_id,
            'HumanReadable': message,
            'EntryContext': {
                'SEPM.Quarantine': context
            }
        })


    def scan_endpoint_command(token):
        endpoint = demisto.getArg('endpoint')
        scan_type = demisto.getArg('scanType')

        if not endpoint:
            return_error('Please provide the IP address or the hostname of endpoint.')
        elif validate_ip(endpoint):
            computer_id = get_computer_id(token, endpoint, None)
        else:
            computer_id = get_computer_id(token, None, endpoint)
        command_id = scan(token, computer_id, scan_type)
        message = '### Initiated scan on endpoint: {0} with type: {1}. Command ID: {2}.'.format(endpoint, scan_type, command_id)
        context = {
            'CommandID': command_id,
            'Type' : scan_type,
            'Endpoint' : endpoint
        }

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['text'],
            'Contents': command_id,
            'HumanReadable': message,
            'EntryContext': {
                'SEPM.Scan': context
            }
        })


    def update_endpoint_content_command(token):
        endpoint = demisto.getArg('endpoint')
        if not endpoint:
            return_error('Please provide the IP address or the hostname of endpoint.')
        elif validate_ip(endpoint):
            computer_id = get_computer_id(token, endpoint, None)
        else:
            computer_id = get_computer_id(token, None, endpoint)

        command_id = update_content(token, computer_id)
        message = '### Updating endpoint: {0}. Command ID: {1}.'.format(endpoint, command_id)
        context = {
            'CommandID': command_id,
            'Endpoint' : endpoint
        }

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['text'],
            'Contents': command_id,
            'HumanReadable': message,
            'EntryContext': {
                'SEPM.Update': context
            }
        })

    # @@@@@@@@@@@@@@@@@@@@@@@@@@    COMMANDS SWITCH    @@@@@@@@@@@@@@@@@@@@@@@@@@
    '''
    Before EVERY command the follwing tow lines are performed (do_auth and get_token_from_response)
    '''
    resp = do_auth(server = demisto.getParam('server'), crads = demisto.getParam('authentication'), insecure = demisto.getParam('insecure'))
    token = get_token_from_response(resp)
    if demisto.command() == 'test-module':
        # This is the call made when pressing the integration test button.
        if token:
            demisto.results('ok')
    if demisto.command() == 'sep-system-info':
        system_info_command(token)
    if demisto.command() == 'sep-client-content':
        client_content_command(token)
    if demisto.command() == 'sep-endpoints-info':
        endpoints_info_command(token)
    if demisto.command() == 'sep-groups-info':
        groups_info_command(token)
    if demisto.command() == 'sep-command-status':
        command_status(token)
    if demisto.command() == 'sep-quarantine':
        run_client_command(token, 'sep-quarantine')
    if demisto.command() == 'sep-update-content':
        run_client_command(token, 'sep-update-content')
    if demisto.command() == 'sep-scan':
        run_client_command(token, 'sep-scan')
    if demisto.command() == 'sep-list-policies':
        list_policies_command(token)
    if demisto.command() == 'sep-assign-policie':
        assign_policie_command(token)
    if demisto.command() == 'sep-list-locations':
        list_locations_command(token)
    if demisto.command() == 'sep-endpoint-quarantine':
        endpoint_quarantine_command(token)
    if demisto.command() == 'sep-scan-endpoint':
        scan_endpoint_command(token)
    if demisto.command() == 'sep-update-endpoint-content':
        update_endpoint_content_command(token)


















  type: python
  commands:
  - name: sep-endpoints-info
    arguments:
    - name: columns
      description: The columns to show.
    - name: computerName
      description: The host name of computer. Wild card is supported as '*'.
    - name: lastUpdate
      description: Indicates when a computer last updated its status. The default
        value of 0 gets all the results.
    - name: os
      auto: PREDEFINED
      predefined:
      - CentOs
      - Debian
      - Fedora
      - MacOSX
      - Oracle
      - OSX
      - RedHat
      - SUSE
      - Ubuntu
      - Win10
      - Win2K
      - Win7
      - Win8
      - WinEmb7
      - WinEmb8
      - WinEmb81
      - WinFundamental
      - WinNT
      - Win2K3
      - Win2K8
      - Win2K8R2
      - WinVista
      - WinXP
      - WinXPEmb
      - WinXPProf64
      description: The list of OS to filter.
    - name: pageSize
      description: The number of results to include on each page. The default is 20.
    - name: computerNamed
      description: Specify  computer name to filter results by this computer name
    outputs:
    - contextPath: SEPM.Endpoint.Hostname
      description: The endpoint's hostname.
      type: string
    - contextPath: SEPM.Endpoint.Domain
      description: The endpoint's domain.
      type: string
    - contextPath: SEPM.Endpoint.IPAddresses
      description: The endpoint's IP addresses.
      type: string
    - contextPath: SEPM.Endpoint.OS
      description: The endpoint's OS information.
      type: string
    - contextPath: SEPM.Endpoint.Description
      description: The endpoint's description.
      type: string
    - contextPath: SEPM.Endpoint.MACAddresses
      description: The endpoint's MAC address.
      type: string
    - contextPath: SEPM.Endpoint.BIOSVersion
      description: The endpoint's BIOS version.
      type: string
    - contextPath: SEPM.Endpoint.DHCPServer
      description: The endpoint's DHCP server address.
      type: string
    description: Get information about endpoints.
  - name: sep-update-content
    arguments:
    - name: ip
      description: The IP of the endpoint.
    - name: hostname
      description: The hostname of the endpoint.
    - name: timeout
      description: The timeout of the command.
    - name: interval
      description: The polling interval of the command.
    outputs:
    - contextPath: SEPM.LastCommand.CommandDetails
      description: The details of the command.
    - contextPath: SEPM.LastCommand.CommandId
      description: The ID of the command.
    description: Updates the content of the given client.
  - name: sep-scan
    arguments:
    - name: ip
      description: The IP of the endpoint.
    - name: scanType
      required: true
      auto: PREDEFINED
      predefined:
      - ScanNow_Quick
      - ScanNow_Full
      - ScanNow_Custom
      description: Type of scan.
    - name: hostname
      description: The hostname of the endpoint.
    - name: timeout
      description: The timeout of the command.
    - name: interval
      description: The polling interval of the command.
    outputs:
    - contextPath: SEPM.LastCommand.CommandDetails
      description: The details of the command.
      type: string
    - contextPath: SEPM.LastCommand.CommandId
      description: The ID of the command.
      type: string
    description: Scans an endpoint.
  - name: sep-groups-info
    arguments:
    - name: columns
      description: The columns to show.
    outputs:
    - contextPath: SEPM.Groups
      description: The list of groups.
    description: Get information about groups.
  - name: sep-system-info
    arguments: []
    outputs:
    - contextPath: SEPM.ServerAVDefVersion
      description: The serverAV definition version.
      type: string
    description: Get the system information (version, AV definition).
  - name: sep-command-status
    arguments:
    - name: commandId
      required: true
      description: The command ID.
    outputs:
    - contextPath: SEPM.LastCommand.CommandDetails
      description: The details of the command.
      type: string
    - contextPath: SEPM.LastCommand.CommandId
      description: The ID of the command.
      type: string
    description: Retrieves the status of a command.
  - name: sep-quarantine
    arguments:
    - name: ip
      description: The IP address of the endpoint.
    - name: hostname
      description: The hostname of the endpoint.
    - name: timeout
      description: The timeout of the command.
    - name: interval
      description: The polling interval of the command.
    - name: actionType
      required: true
      auto: PREDEFINED
      predefined:
      - Quarantine
      - Undo
      description: The action type.
    outputs:
    - contextPath: SEPM.LastCommand.CommandDetails
      description: The details of the command.
      type: string
    - contextPath: SEPM.LastCommand.CommandId
      description: The ID of the command.
      type: string
    description: Quarantines the endpoint according to its policy.
  - name: sep-client-content
    arguments: []
    outputs:
    - contextPath: SEPM.ClientContentVersions
      description: The versions of the clients.
      type: string
    - contextPath: SEPM.LastUpdated
      description: The last-updated date.
      type: string
    description: Retrieves the client content.
  - name: sep-list-policies
    arguments: []
    outputs:
    - contextPath: SEPM.PoliciesList.PolicyName
      description: Name of policy
      type: string
    - contextPath: SEPM.PoliciesList.Type
      description: Policy type
      type: string
    - contextPath: SEPM.PoliciesList.ID
      description: Policy ID
      type: string
    - contextPath: SEPM.PoliciesList.Discription
      description: Policy discription
      type: string
    - contextPath: SEPM.PoliciesList.Enabled
      description: True if enabled false otherwise
      type: boolean
    - contextPath: SEPM.PoliciesList.AssignedLocations.GroupID
      description: 'Group ID of the locations assigned with this policy '
      type: string
    - contextPath: SEPM.PoliciesList.AssignedLocations.Locations
      description: List of locations IDs assigned with this policy
      type: string
    - contextPath: SEPM.PoliciesList.AssignedCloudGroups.GroupID
      description: 'Cloud Group ID of the locations assigned with this policy '
      type: string
    - contextPath: SEPM.PoliciesList.AssignedCloudGroups.Locations
      description: List of locations IDs belonging to a cloud group assigned with
        this policy
      type: string
    description: 'Retrieve a list of existing policies '
  - name: sep-assign-policie
    arguments:
    - name: groupID
      required: true
      description: 'The ID of the group the location belongs to '
    - name: locationID
      required: true
      description: The ID of the designated location
    - name: policyType
      required: true
      description: The type of policy to be assigned
    - name: policyID
      required: true
      description: The ID of policy to be assigned
    description: 'Assign existing policy to a designated location '
  - name: sep-list-locations
    arguments:
    - name: groupID
      required: true
      description: The ID of the group holding the locations
    outputs:
    - contextPath: SEPM.Locations.ID
      desciption: The ID of the location
    description: 'Retrieve a list of location ID''s for a given group '
  - name: sep-endpoint-quarantine
    arguments:
    - name: endpoint
      required: true
      description: IP or Host Name of the endpoint
    - name: actionType
      required: true
      auto: PREDEFINED
      predefined:
      - Add
      - Remove
      description: Add or Remove
    outputs:
    - contextPath: SEPM.Quarantine.CommandID
      description: ID of the invoked command
      type: string
    - contextPath: SEPM.Quarantine.Action
      description: The action type ('Add' or 'Remove')
      type: string
    - contextPath: SEPM.Quarantine.Endpoint
      description: The endpoint identifier (IP or Host Name)
      type: string
    description: Quarantines the endpoint according to its policy.
  - name: sep-scan-endpoint
    arguments:
    - name: endpoint
      required: true
      description: IP or Host Name of the endpoint
    - name: scanType
      required: true
      auto: PREDEFINED
      predefined:
      - ScanNow_Quick
      - ScanNow_Full
      - ScanNow_Custom
      description: Type of the scan (ScanNow_Quick, ScanNow_Full or ScanNow_Custom)
    outputs:
    - contextPath: SEPM.Scan.CommandID
      description: ID of the invoked command
      type: string
    - contextPath: SEPM.Scan.Type
      description: Type of the scan (ScanNow_Quick, ScanNow_Full or ScanNow_Custom)
      type: string
    - contextPath: SEPM.Quarantine.Endpoint
      description: The endpoint identifier (IP or Host Name)
    description: Scans an endpoint.
  - name: sep-update-endpoint-content
    arguments:
    - name: endpoint
      description: IP or Host Name of the endpoint
    description: Updates the content of the given client.
  runonce: false
releaseNotes: "Enhancments for the integration. New commands sep-list-policies - Retrieve a list of existing policies, sep-assign-policie - Assign existing policy to a designated location. sep-list-locations - Retrieve a list of location ID's for a given group. sep-endpoint-quarantine - Quarantines the endpoint according to its policy. sep-scan-endpoint - Scans an endpoint. sep-update-endpoint-content - Updates the content of the given client."
tests:
  - No test


