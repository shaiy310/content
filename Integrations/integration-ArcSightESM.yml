commonfields:
  id: ArcSight ESM
  version: -1
name: ArcSight ESM
display: ArcSight ESM
category: Analytics & SIEM
image: data:image/png;base64,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
description: ArcSight ESM SIEM by Micro Focus (Formerly HPE Software).
configuration:
- display: Server URL (e.g. https://192.168.0.1)
  name: server
  defaultvalue: ""
  type: 0
  required: true
- display: Port
  name: port
  defaultvalue: "8443"
  type: 0
  required: true
- display: Credentials
  name: credentials
  defaultvalue: ""
  type: 9
  required: true
- display: Fetch Events as incidents via Query Viewer ID. Mandatory fields for query
    are Start Time and Event ID.
  name: events_query_viewer_id
  defaultvalue: ""
  type: 0
  required: false
- display: Fetch Cases as incidents via Query Viewer ID. Mandatory fields for query
    are Create Time and ID.
  name: cases_query_viewer_id
  defaultvalue: ""
  type: 0
  required: false
- display: Do not validate server certificate (unsecure)
  name: unsecure
  defaultvalue: "true"
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: "false"
  type: 8
  required: false
- display: Fetch incidents
  name: isFetch
  defaultvalue: ""
  type: 8
  required: false
- display: Incident type
  name: incidentType
  defaultvalue: ""
  type: 13
  required: false
script:
  script: |-
    from collections import deque
    import requests
    from datetime import datetime

    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    """ GLOBALS """
    URL, PORT = demisto.params().get('server'), demisto.params().get('port')
    BASE_URL = URL.rstrip('/:') + ':' + PORT + '/'
    VERIFY_CERTIFICATE = not demisto.params().get('unsecure', True)
    HEADERS = {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    }

    RELEVANT_CASE_ENTRIES = {
        'Name': 'name',
        'EventIDs': 'eventIDs',
        'Action': 'action',
        'Stage': 'stage',
        'CaseID': 'resourceid',
        'Severity': 'consequenceSeverity'
    }
    RELEVANT_EVENT_ENTRIES = {
        'Event ID': 'eventId',
        'Time': 'endTime',
        'Source Address': 'source.address',
        'Destination Address': 'destination.address',
        'Name': 'name',
        'Source Port': 'source.port',
        'Base Event IDs': 'baseEventIds'
    }

    REQ_SOAP_BODY = """<?xml version="1.0" encoding="UTF-8"?>
        <soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
        xmlns:act="http://ws.v1.service.resource.manager.product.arcsight.com/activeListService/">
        <soapenv:Header />
            <soapenv:Body>
                <act:{function}>
                    <act:authToken>{auth_token}</act:authToken>
                    <act:resourceId>{resource_id}</act:resourceId>
                    {entryList}
                </act:{function}>
            </soapenv:Body>
        </soapenv:Envelope>
    """.format

    ENTRY_LIST = "<entryList>{}</entryList>".format
    ENTRY = "<entry>{}</entry>".format
    COLUMN = "<columns>{}</columns>".format
    BODY = "<act:entryList>{}</act:entryList>".format

    AS_NONE_VALUES = [-9223372036854776000, -9223372036854775808, -2147483648]
    AS_IP_VALUES = ['address', 'Destination Address', 'Source Address']
    AS_TIME_FIELDS = ['createdTimestamp', 'modifiedTimestamp', 'deviceReceiptTime', 'startTime', 'endTime',
                      'stageUpdateTime', 'modificationTime', 'managerReceiptTime', 'createTime', 'agentReceiptTime']

    if not demisto.params().get("proxy", False):
        del os.environ["HTTP_PROXY"]
        del os.environ["HTTPS_PROXY"]
        del os.environ["http_proxy"]
        del os.environ["https_proxy"]


    def int_to_ip(num):
        """ IP stored as an int within the ArcSight DB. This function transform it into IPv4 format """
        return "{}.{}.{}.{}".format((num >> 24) & 255, (num >> 16) & 255, (num >> 8) & 255, num & 255)


    def parse_timestamp_to_datestring(timestamp):
        if timestamp not in AS_NONE_VALUES:
            try:
                return datetime.fromtimestamp(timestamp / 1000.0).strftime("%Y-%m-%dT%H:%M:%S.000Z")
            except (ValueError, TypeError) as e:
                LOG(e.message)
                return timestamp


    def beautifully_json(d, depth=0):
        """ Converts some of the values from ArcSight DB into a more useful & readable format """
        if depth < 10:
            if isinstance(d, list):
                return [beautifully_json(d_, depth + 1) for d_ in d]
            if isinstance(d, dict):
                for key, value in d.items():
                    if isinstance(value, dict):
                        beautifully_json(value, depth + 1)
                    elif value in AS_NONE_VALUES:
                        d[key] = None
                    elif value in AS_IP_VALUES:
                        d[key] = int_to_ip(value)
                    elif key in AS_TIME_FIELDS:
                        d[key] = parse_timestamp_to_datestring(value)


    def generate_entry(raw, table, out, title=None, context=None, headers=None, to_enrich=None):
        beautifully_json(raw)
        return {
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': raw,
            'HumanReadable': tableToMarkdown(name=title, headers=headers, t=table) if title else table,
            'EntryContext': {'ArcSightESM.{}'.format(out) + (
                '(val.{to_enrich}===obj.{to_enrich})'.format(to_enrich=to_enrich) if to_enrich else ''): context or raw}
        }


    def login():
        query_path = 'www/core-service/rest/LoginService/login'
        headers = {
            'Content-Type': 'application/x-www-form-urlencoded',
            'Accept': 'application/json'
        }
        params = {
            'login': demisto.get(demisto.params(), 'credentials.identifier'),
            'password': demisto.get(demisto.params(), 'credentials.password'),
            'alt': 'json'
        }
        res = send_request(query_path, headers=headers, params=params)
        if not res.ok:
            return_error('Failed to login, check integration parameters.')

        try:
            res_json = json.loads(res.text)
            if 'log.loginResponse' in res_json and 'log.return' in res_json.get('log.loginResponse'):
                return res_json.get('log.loginResponse').get('log.return')

            return_error('Failed to login. Have not received token after login')
        except ValueError:
            return_error('Failed to login. Please check URL and Credentials')


    def logout():
        query_path = 'www/core-service/rest/LoginService/logout'
        headers = {
            'Content-Type': 'application/x-www-form-urlencoded',
            'Accept': 'application/json'
        }
        params = {
            'authToken': AUTH_TOKEN,
            'alt': 'json'
        }
        res = send_request(query_path, headers=headers, params=params)
        if not res.ok:
            return_error('Failed to login, check integration parameters.')


    def send_request(query_path, body=None, params=None, json=None, headers=None, method='post'):
        if headers is None:
            headers = HEADERS
        full_url = BASE_URL + query_path
        request_func = requests.post if method == 'post' else requests.get
        try:
            return request_func(
                full_url,
                headers=headers,
                verify=VERIFY_CERTIFICATE,
                data=body,
                params=params,
                json=json
            )
        except requests.exceptions.ConnectionError as e:
            return_error('Connection Error. Please check URL')


    def test(events_query_viewer_id=None, cases_query_viewer_id=None, isFetch=False, **kwarg):
        """
        Login (already done in global).
        Test if fetch query viewers are valid.
        Run query viewer if fetch defined.
        """
        if isFetch and not events_query_viewer_id and not cases_query_viewer_id:
            return_error('If fetch is enabled, you must provide query viewer Resource ID for Cases or Events')

        if events_query_viewer_id:
            fields, results = get_query_viewer_results(events_query_viewer_id)
            if 'Event ID' not in fields or 'Start Time' not in fields:
                return_error('Query "{}" must contain "Start Time" and "Event ID" fields'.format(cases_query_viewer_id))

        if cases_query_viewer_id:
            fields, results = get_query_viewer_results(cases_query_viewer_id)
            if 'ID' not in fields or 'Create Time' not in fields:
                return_error('Query "{}" must contain "Create Time" and "ID" fields'.format(cases_query_viewer_id))


    def get_query_viewer_results(query_viewer_id):
        query_path = 'www/manager-service/rest/QueryViewerService/getMatrixData'
        params = {
            'authToken': AUTH_TOKEN,
            'id': query_viewer_id,
            'alt': 'json'
        }
        res = send_request(query_path, params=params, method='get')

        if not res.ok:
            if 'ResourceNotFoundException' in res.text:
                return_error('Invalid resource ID {} for Query Viewer(ResourceNotFoundException)'.format(query_viewer_id))
            else:
                return_error('Failed to get query viewer results.')

        return_object = None
        res_json = json.loads(res.text)
        if "qvs.getMatrixDataResponse" in res_json and "qvs.return" in res_json["qvs.getMatrixDataResponse"]:
            # ArcSight ESM version 6.7 & 6.9 rest API supports qvs.getMatrixDataResponse
            return_object = res_json.get("qvs.getMatrixDataResponse").get("qvs.return")

        elif "que.getMatrixDataResponse" in res_json and "que.return" in res_json["que.getMatrixDataResponse"]:
            # ArcSight ESM version 6.1 rest API supports que.getMatrixDataResponse
            return_object = res_json.get("que.getMatrixDataResponse").get("que.return")

        else:
            return_error('Invalid response structure. Open ticket to Demisto support and attach the logs')

        fields = return_object.get('columnHeaders', [])
        if not isinstance(fields, (list,)):
            fields = [fields]

        results = return_object.get("rows", [])
        if not isinstance(results, (list,)):
            results = [results]

        if len(fields) == 0 or len(results) == 0:
            return fields, results

        """
        we parse the rows by column headers and create formatted result

        "columnHeaders": [
            "ID",
            "Event-Event ID",
        ],
        "rows": [
            {
                "@xsi.type": "listWrapper",
                "value": [
                    {
                        "@xsi.type": "xs:string",
                        "$": "<ID1>"
                    },
                    {
                        "@xsi.type": "xs:string",
                        "$": "<Event-Event ID1>"
                    }
                ]
            },
            {
                "@xsi.type": "listWrapper",
                "value": [
                    {
                        "@xsi.type": "xs:string",
                        "$": "<ID2>"
                    },
                    {
                        "@xsi.type": "xs:string",
                        "$": "<Event-Event ID2>"
                    }
                ]
            }
        ]

        convert to ===>

        query_results = [
            {
                Event-Event ID:<Event-Event ID1>
                ID:<ID1>
            },
            {
                Event-Event ID:<Event-Event ID2>
                ID:<ID2>
            }
        ]
        """
        results = [{field: result.get('value')[idx].get('$') for idx, field in enumerate(fields)} for result in results]
        return fields, results


    def get_query_viewer_results_command(id):
        columns, query_results = get_query_viewer_results(query_viewer_id=id)

        demisto.results({
            'Type': entryTypes['note'],
            'ContentsFormat': formats['json'],
            'Contents': {'results': query_results}
        })


    def fetch(events_query_viewer_id=None, cases_query_viewer_id=None, **kwarg):
        """
        Query viewer should be defined in ArcSight ESM. fetch incidents fetches the results of query viewer
        and converts them to Demisto incidents. We can query Cases or Events. If Cases are fetched then the
        query viewer query must return fields ID and Create Time. If Events are fetched then Event ID and Start Time.
        """
        last_run = demisto.getLastRun()
        last_create_time = last_run.get('last_create_time', 0)
        already_fetched = deque(last_run.get('already_fetched', []), maxlen=1000)
        latest_created_time = last_create_time

        fields, query_results = get_query_viewer_results(events_query_viewer_id or cases_query_viewer_id)
        incidents = []
        for result in query_results:
            # convert case or event to demisto incident
            r_id = result.get('ID') or result.get('Event ID')
            create_time = int(result.get('Start Time') or result.get('Create Time'))
            if create_time >= last_create_time and r_id not in already_fetched:
                # check if case/event already was fetched before
                latest_created_time = create_time if create_time > latest_created_time else latest_created_time

                result['Create Time'] = parse_timestamp_to_datestring(create_time)
                incident = {
                    'name': 'ArcSight Case #{}'.format(r_id),
                    'occurred': result['Create Time'],
                    'labels': [{'type': key, 'value': str(value)} for key, value in result.items()],
                    'rawJSON': json.dumps(result)
                }
                incidents.append(incident)
                already_fetched.append(r_id)

        last_run['last_create_time'] = latest_created_time
        last_run['already_fetched'] = list(already_fetched)
        demisto.setLastRun(last_run)
        beautifully_json(incidents)

        if demisto.command() == 'as-fetch-incidents':
            demisto.results({
                'Type': entryTypes['note'],
                'ContentsFormat': formats['json'],
                'Contents': {
                    'incidents': incidents,
                    'last_create_time': latest_created_time,
                    'already_fetched': list(already_fetched)}
            })
        demisto.incidents(incidents)


    def get_case(resourceId, fetch_base_events=False):
        query_path = 'www/manager-service/rest/CaseService/getResourceById'
        params = {
            'authToken': AUTH_TOKEN,
            'resourceId': resourceId,
        }
        res = send_request(query_path, params=params, method='get')

        if not res.ok:
            if 'InvalidResourceIDException: Invalid resource ID' in res.text and 'for Case' in res.text:
                return_error('Invalid resource ID {} for Case'.format(resourceId))
            else:
                return_error('Failed to get case. StatusCode: {}'.format(res.status_code))

        res_json = json.loads(res.text)
        if 'cas.getResourceByIdResponse' in res_json and 'cas.return' in res_json.get('cas.getResourceByIdResponse'):
            case = res_json.get('cas.getResourceByIdResponse').get('cas.return')

            if 'eventIDs' in case and case['eventIDs'] and isinstance(case['eventIDs'], int):
                # if eventIDs is single id then convert to list
                case['eventIDs'] = [case['eventIDs']]

            if fetch_base_events:
                case['events'] = get_security_events(case['eventIDs'])

            return case

        return_error('Case {} not found'.format(resourceId))


    def get_case_command(resourceId, withBaseEvents=False):
        raw_case = get_case(resourceId, fetch_base_events=withBaseEvents == 'true')
        relevant_entries = {new_key: raw_case.get(old_key) for new_key, old_key in RELEVANT_CASE_ENTRIES.items()}
        relevant_entries['CreatedTime'] = FormatADTimestamp(raw_case.get('createdTimestamp'))
        demisto.results(generate_entry(raw_case, relevant_entries, title='Case ' + resourceId, out='Cases', to_enrich='resourceid'))


    def get_all_cases_command():
        query_path = 'www/manager-service/rest/CaseService/findAllIds'
        params = {
            'authToken': AUTH_TOKEN,
            'alt': 'json'
        }
        res = send_request(query_path, params=params, method='get')

        if not res.ok:
            return_error('Failed to get case list. StatusCode: {}'.format(res.status_code))

        all_cases = res.json().get('cas.findAllIdsResponse').get('cas.return')
        demisto.results(generate_entry(all_cases, all_cases, title='All cases', headers='caseID', out='AllCaseIDs'))


    def extract_relevant_event_entries(raw_events):
        events = []
        for event in raw_events:
            event_entries = {}
            for new_key, key in RELEVANT_EVENT_ENTRIES.items():
                event_entries[new_key] = int_to_ip(demisto.get(event, key)) if 'Address' in new_key else demisto.get(event, key)
                if new_key is 'Time':
                    event_entries[new_key] = timestamp_to_datestring(event_entries[new_key], '%Y-%m-%d, %H:%M:%S')
            events.append(event_entries)

        return events


    def get_security_events_command(ids, lastDateRange=None):
        if isinstance(ids, basestring):
            # if ids is string then convert to list
            ids = argToList(ids)

        raw_events = get_security_events(ids, lastDateRange)
        if raw_events:
            hr = tableToMarkdown('Security Event: {}'.format(','.join(ids)), extract_relevant_event_entries(raw_events))
            demisto.results(generate_entry(raw=raw_events, table=hr, out='SecurityEvents', to_enrich='eventId'))

        else:
            demisto.results('No events were found')


    def get_security_events(event_ids, last_date_range=None):
        start_time, end_time = -1, -1
        if last_date_range:
            # Must of format 'number date_range_unit'
            # Examples: (2 hours, 4 minutes, 6 month, 1 day, etc.)
            start_time, end_time = parse_date_range(last_date_range, to_timestamp=True)

        query_path = 'www/manager-service/rest/SecurityEventService/getSecurityEvents'
        params = {
            'alt': 'json'
        }
        json_ = {
            "sev.getSecurityEvents": {
                "sev.authToken": AUTH_TOKEN,
                "sev.ids": event_ids,
                "sev.startMillis": start_time,
                "sev.endMillis": end_time
            }
        }
        res = send_request(query_path, json=json_, params=params)

        if not res.ok:
            return_error(
                'Failed to get security events with ids {}.\nFull URL: {}\nStatus Code: {}\nResponse Body: {}'.format(
                    event_ids, BASE_URL + query_path, res.status_code, res.text))

        res_json = json.loads(res.text)
        if res_json.get('sev.getSecurityEventsResponse') and res_json.get('sev.getSecurityEventsResponse').get(
                'sev.return'):
            events = res_json.get('sev.getSecurityEventsResponse').get('sev.return')
            return events if isinstance(events, list) else [events]

        return_error('Events are empty for some reason. Response Body: {}'.format(res.text))


    def update_case_command(caseId, stage, severity):
        updated_case = update_case(caseId, stage, severity)
        relevant_entries = {new_key: updated_case.get(old_key) for new_key, old_key in RELEVANT_CASE_ENTRIES.items()}
        relevant_entries["CreatedTime"] = FormatADTimestamp(updated_case.get("createdTimestamp"))

        demisto.results(generate_entry(raw=updated_case, table=relevant_entries, title='Case ' + caseId, out='Cases',
                                       to_enrich='resourceid'))


    def update_case(caseId, stage, severity=None):
        # get the case from arcsight
        case = get_case(caseId)
        case['stage'] = stage
        case['consequenceSeverity'] = severity if severity else case['consequenceSeverity']

        # update its stage and send it back to arcsight
        query_path = 'www/manager-service/rest/CaseService/update'
        params = {
            'alt': 'json'
        }
        json_ = {
            "cas.update": {
                "cas.authToken": AUTH_TOKEN,
                "cas.resource": case,
            }
        }
        res = send_request(query_path, json=json_, params=params)

        if not res.ok:
            return_error('Failed to get security update case {}\nFull URL: {}\nStatus Code: {}\nResponse Body: {}'.format(
                caseId, BASE_URL + query_path, res.status_code, res.text))

        res_json = json.loads(res.text)
        if 'cas.updateResponse' in res_json and 'cas.return' in res_json.get('cas.updateResponse'):
            return case

        return_error('Failed to update case, fail to parse response. Response Body: {}'.format(res.text))


    def get_case_event_ids_command(caseId):
        query_path = 'www/manager-service/rest/CaseService/getCaseEventIDs'
        params = {
            'authToken': AUTH_TOKEN,
            'caseId': caseId
        }

        res = send_request(query_path, params=params, method='get')
        if not res.ok:
            return_error("Failed to get Event IDs with:\nStatus Code: {}\nResponse: {}".format(res.status_code, res.text))

        res_json = json.loads(res.text)
        if 'cas.getCaseEventIDsResponse' in res_json and 'cas.return' in res_json.get('cas.getCaseEventIDsResponse'):
            event_ids = res_json.get('cas.getCaseEventIDsResponse').get('cas.return')
            if not isinstance(event_ids, list):
                event_ids = [event_ids]
            demisto.results(generate_entry(raw=res_json, table=event_ids, title='Case {}'.format(caseId), out='CaseEvents',
                                           headers='Event ID', context=event_ids))
        else:
            demisto.results('No IDs were found')


    def delete_case_command(caseId):
        query_path = 'www/manager-service/rest/CaseService/deleteByUUID'
        req_body = json.dumps({
            'cas.deleteByUUID': {
                'cas.authToken': AUTH_TOKEN,
                'cas.id': caseId
            }
        })
        params = {
            'alt': 'json'
        }
        res = send_request(query_path, params=params, body=req_body)
        if not res.ok:
            return_error("Failed to delete case:\nStatus Code: {}\nResponse: {}".format(res.status_code, res.text))


    def get_entries_command(resourceId, entryFilter=None):
        query_path = 'www/manager-service/services/ActiveListService/'
        body = REQ_SOAP_BODY(function='getEntries', auth_token=AUTH_TOKEN, resource_id=resourceId, entryList=None)

        res = send_request(query_path, body=body)

        if not res.ok:
            return_error("Failed to get entries:\nResource ID: {}\nStatus Code: {}\nRequest Body: {}\nResponse: {}".format(
                resourceId, res.status_code, body, res.text))

        res_json = json.loads(xml2json(res.text))
        raw_entries = demisto.get(res_json, 'Envelope.Body.getEntriesResponse.return')
        if 'entryList' in raw_entries:
            entry_list = raw_entries['entryList'] if isinstance(raw_entries['entryList'], list) else [raw_entries['entryList']]
            entry_list = [d['entry'] for d in entry_list if 'entry' in d]
            keys = raw_entries.get('columns')
            entries = [dict(zip(keys, values)) for values in entry_list]
            filtered = entries
            # if the user wants only entries that contain certain 'field:value' sets (filters)
            # e.g. "name:myName,eventId:0,:ValueInUnknownField"
            # if the key is empty, search in every key
            if entryFilter:
                for f in entryFilter.split(','):
                    k, v = f.split(':')
                    filtered = [entry for entry in filtered if ((entry.get(k) == v) if k else (v in entry.values()))]

            demisto.results(
                generate_entry(raw=filtered, table=filtered, out='ActiveList.{}'.format(resourceId), title='Active List entries'))
        else:
            demisto.results('No Entries were found for this Active List.')


    def clear_entries_command(resourceId):
        query_path = 'www/manager-service/services/ActiveListService/'
        body = REQ_SOAP_BODY(function='clearEntries', auth_token=AUTH_TOKEN, resource_id=resourceId, entryList=None)
        res = send_request(query_path, body=body)

        if not res.ok:
            return_error(
                "Failed to clear entries with:\nResource ID: {}\nStatus Code: {}\nRequest Body: {}\nResponse: {}".format(
                    resourceId, res.status_code, body, res.text))

        demisto.results("Success")


    def add_entries_command(resourceId, entries):
        query_path = 'www/manager-service/services/ActiveListService/'
        if not isinstance(entries, dict):
            try:
                entries = json.loads(entries)
            except ValueError as e:
                return_error('Entries must be in JSON format. Must be array of objects.')
            if not all([entry.keys() == entries[0].keys() for entry in entries[1:]]):
                return_error('All entries must have the same fields')

        columns = ''.join(COLUMN(column) for column in entries[0])  # the fields in the entryList matrix are the columns
        entry_list = BODY(columns + ''.join(ENTRY_LIST(''.join(ENTRY(v) for v in en.values())) for en in entries))
        body = REQ_SOAP_BODY(function='addEntries', auth_token=AUTH_TOKEN, resource_id=resourceId, entryList=entry_list)
        res = send_request(query_path, body=body)

        if not res.ok:
            return_error("Failed to clear entries with:\nResource ID: {}\nStatus Code: {}\nRequest Body: {}\nResponse: {}".format(
                resourceId, res.status_code, body, res.text))

        demisto.results("Success")


    def get_all_query_viewers_command():
        query_path = 'www/manager-service/rest/QueryViewerService/findAllIds'
        params = {
            'authToken': AUTH_TOKEN,
            'alt': 'json'
        }
        headers = {
            'Content-Type': 'application/x-www-form-urlencoded',
            'Accept': 'application/json'
        }
        res = send_request(query_path, headers=headers, params=params)
        if not res.ok:
            return_error("Failed to get query viewers:\nStatus Code: {}\nResponse: {}".format(res.status_code, res.text))

        res_json = json.loads(res.text)
        if 'qvs.findAllIdsResponse' in res_json and 'qvs.return' in res_json.get('qvs.findAllIdsResponse'):
            query_viewers = res_json.get('qvs.findAllIdsResponse').get('qvs.return')
            demisto.results(generate_entry(query_viewers, query_viewers, title='Query Viewers', headers='Query Viewers ID',
                                           out='AllQueryViewers'))
        else:
            demisto.results('No Query Viewers were found')


    AUTH_TOKEN = login()
    try:
        if demisto.command() == 'test-module':
            test(**demisto.params())
            demisto.results('ok')

        elif demisto.command() == 'as-fetch-incidents' or demisto.command() == 'fetch-incidents':
            if demisto.args().get('lastRun'):
                last_run = json.loads(demisto.args().get('lastRun'))
                demisto.setLastRun(last_run)

            fetch(**demisto.params())

        elif demisto.command() == 'as-get-matrix-data' or demisto.command() == 'as-get-query-viewer-results':
            get_query_viewer_results_command(**demisto.args())

        elif demisto.command() == 'as-get-all-cases':
            get_all_cases_command()

        elif demisto.command() == 'as-get-case':
            get_case_command(**demisto.args())

        elif demisto.command() == 'as-update-case':
            update_case_command(**demisto.args())

        elif demisto.command() == 'as-case-delete':
            delete_case_command(**demisto.args())

        elif demisto.command() == 'as-get-security-events':
            get_security_events_command(**demisto.args())

        elif demisto.command() == 'as-get-entries':
            get_entries_command(**demisto.args())

        elif demisto.command() == 'as-add-entries':
            add_entries_command(**demisto.args())

        elif demisto.command() == 'as-clear-entries':
            clear_entries_command(**demisto.args())

        elif demisto.command() == 'as-get-case-event-ids':
            get_case_event_ids_command(**demisto.args())

        elif demisto.command() == 'as-get-all-query-viewers':
            get_all_query_viewers_command()

        LOG.print_log()


    except Exception, e:
        LOG(e.message)
        LOG.print_log()
        return_error(e.message)
    finally:
        logout()
  type: python
  commands:
  - name: as-get-all-cases
    arguments: []
    outputs:
    - contextPath: ArcSightESM.AllCaseIDs
      description: All cases resource ids
      type: Unknown
    description: (Deprecated) Retrieve all case resource ids
  - name: as-get-case
    arguments:
    - name: resourceId
      required: true
      default: true
      description: commands.server.arcsight.arguments.caseid.description
    - name: withBaseEvents
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: If passed true, then will return case and base events of that case.
      defaultValue: "false"
    outputs:
    - contextPath: ArcSightESM.Cases.resourceid
      description: The resource id of case
      type: string
    - contextPath: ArcSightESM.Cases.name
      description: Name of the case
      type: string
    - contextPath: ArcSightESM.Cases.eventIDs
      description: Related base event ids
      type: Unknown
    - contextPath: ArcSightESM.Cases.createdTimestamp
      description: Created timestamp (in milliseconds)
      type: number
    - contextPath: ArcSightESM.Cases.createdTime
      description: Created Time (dd-mm-yyyyTHH:MM:SS.SSS timezone)
      type: string
    - contextPath: ArcSightESM.Cases.modifiedTimestamp
      description: Modified Timestamp (in milliseconds)
      type: number
    - contextPath: ArcSightESM.Cases.modifiedTime
      description: Modified Time (dd-mm-yyyyTHH:MM:SS.SSS timezone)
      type: date
    - contextPath: ArcSightESM.Cases.action
      description: Action (e.g BLOCK_OR_SHUTDOWN)
      type: string
    - contextPath: ArcSightESM.Cases.associatedImpact
      description: Associated Impact (e.g AVAILABILITY)
      type: string
    - contextPath: ArcSightESM.Cases.attackAgent
      description: Attack Agent (e.g INSIDER)
      type: string
    - contextPath: ArcSightESM.Cases.attackMechanism
      description: AttackMechanism (e.g PHYSICAL)
      type: string
    - contextPath: ArcSightESM.Cases.consequenceSeverity
      description: Consequence Severity (e.g NONE)
      type: string
    - contextPath: ArcSightESM.Cases.detectionTime
      description: Detection Time (e.g dd-mm-yyyyTHH:MM:SS.SSS timezone)
      type: date
    - contextPath: ArcSightESM.Cases.displayID
      description: Display ID
      type: number
    - contextPath: ArcSightESM.Cases.estimatedStartTime
      description: Estimated Start Time (e.g dd-mm-yyyyTHH:MM:SS.SSS timezone)
      type: date
    - contextPath: ArcSightESM.Cases.eventIDs
      description: Base event IDs
      type: unknown
    - contextPath: ArcSightESM.Cases.frequency
      description: Frequency (e.g NEVER_OR_ONCE)
      type: string
    - contextPath: ArcSightESM.Cases.history
      description: History (e.g KNOWN_OCCURENCE)
      type: Unknown
    - contextPath: ArcSightESM.Cases.numberOfOccurences
      description: Number Of Occurences
      type: number
    - contextPath: ArcSightESM.Cases.resistance
      description: Resistance (e.g HIGH)
      type: string
    - contextPath: ArcSightESM.Cases.securityClassification
      description: Security Classification (e.g UNCLASSIFIED)
      type: string
    - contextPath: ArcSightESM.Cases.sensitivity
      description: Sensitivity (e.g UNCLASSIFIED)
      type: string
    - contextPath: ArcSightESM.Cases.stage
      description: Stage (e.g QUEUED,INITIAL,FOLLOW_UP,FINAL,CLOSED)
      type: string
    - contextPath: ArcSightESM.Cases.ticketType
      description: Ticket type (e.g INTERNAL,CLIENT,INCIDENT)
      type: string
    - contextPath: ArcSightESM.Cases.vulnerability
      description: Vulnerability (e.g DESIGN)
      type: string
    description: commands.server.arcsight.getspecificcase.description
  - name: as-get-matrix-data
    arguments:
    - name: id
      required: true
      default: true
      description: Resource id of query viewer
    - name: onlyColumns
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: If true will return only the columns of the query. If false will
        return the column headers and all query results.
      defaultValue: "true"
    description: Retrieve query viewer results (query viewer must be configured to
      be refreshed every minute, see documentation)
  - name: as-add-entries
    arguments:
    - name: resourceId
      required: true
      description: resource id of the Active list
    - name: entries
      required: true
      description: 'Entries in JSON format. JSON must be array of entries. Each entry
        must contain the same columns like in the Active list. Example: [{ "UserName":
        "john", "IP":"19.12.13.11"},{ "UserName": "bob", "IP":"22.22.22.22"}]'
      isArray: true
    description: Add new entries to Active List
    execution: true
  - name: as-clear-entries
    arguments:
    - name: resourceId
      required: true
      description: resource id of Active list
    description: Clean all entries in the Active List
    execution: true
  - name: as-get-entries
    arguments:
    - name: resourceId
      required: true
      description: resource id of Active list
    - name: entryFilter
      description: 'Filters the entries. Example: entryFilter="moo:moo1"'
    outputs:
    - contextPath: ArcSightESM.ActiveList
      description: Active List is a map of active list resource id => active list
        entries
      type: Unknown
    - contextPath: ArcSightESM.ActiveList.ListID
      description: The ActiveList ID
      type: list
    - contextPath: ArcSightESM.ActiveList.Entry
      description: Active List is a map of active list resource id => active list
      type: Unknown
    description: Get all entries from Active List
  - name: as-get-security-events
    arguments:
    - name: ids
      required: true
      description: 'ID or multiple ids separated by comma of security events. Event
        ID is ArcSight is always a number. Example: 13906590'
      isArray: true
    - name: lastDateRange
      description: 'Query last events. Must be of format ''number date_range_unit''
        Examples: (2 hours, 4 minutes, 6 month, 1 day, etc.)'
    outputs:
    - contextPath: ArcSightESM.SecurityEvents
      description: List of security events
      type: Unknown
    - contextPath: ArcSightESM.SecurityEvents.name
      description: The name of the event
      type: string
    - contextPath: ArcSightESM.SecurityEvents.eventId
      description: Event id
      type: number
    - contextPath: ArcSightESM.SecurityEvents.type
      description: Type of the event (e.g CORRELATION)
      type: string
    - contextPath: ArcSightESM.SecurityEvents.baseEventIds
      description: Base event ids
      type: Unknown
    - contextPath: ArcSightESM.SecurityEvents.startTime
      description: Start time in milliseconds
      type: date
    description: Returns the security event details
  - name: as-get-case-event-ids
    arguments:
    - name: caseId
      required: true
      description: 'Resource ID of case. Example: 7e6LEbF8BABCfA-dlp1rl1A=='
    outputs:
    - contextPath: ArcSightESM.CaseEvents
      description: Map of caseId => related event ids
      type: Unknown
    - contextPath: ArcSightESM.CaseEvents.LatestResult
      description: Event ids of the last execution of this command
      type: Unknown
    description: Returns all case event IDs
  - name: as-update-case
    arguments:
    - name: caseId
      required: true
      description: Case resource ID
    - name: stage
      auto: PREDEFINED
      predefined:
      - CLOSED
      - QUEUED
      - FINAL
      - FOLLOW_UP
      - INITIAL
      description: The stage of case
    - name: severity
      auto: PREDEFINED
      predefined:
      - NONE
      - INSIGNIFICANT
      - MARGINAL
      - CRITICAL
      - CATASTROPHIC
      description: Ticket Consequence Severity
    outputs:
    - contextPath: ArcSightESM.Cases
      description: List of cases
      type: unknown
    - contextPath: ArcSightESM.Cases.resourceid
      description: Case resource id
      type: string
    - contextPath: ArcSightESM.Cases.stage
      description: 'Case Stage '
      type: string
    - contextPath: ArcSightESM.Cases.consequenceSeverity
      description: Case Severity
      type: string
    description: Updates a case
    execution: true
  - name: as-get-all-query-viewers
    arguments: []
    outputs:
    - contextPath: ArcSightESM.AllQueryViewers
      description: List of all query viewer ids
      type: Unknown
    description: Returns all the query viewer ids
  - name: as-case-delete
    arguments:
    - name: caseId
      required: true
      description: The resource id of the case
    outputs:
    - contextPath: ArcSightESM.Cases.resourceid
      description: Resource id of case
      type: string
    - contextPath: ArcSightESM.Cases.Deleted
      description: Boolean flag. True if deleted.
      type: boolean
    description: Deletes a case
    execution: true
  - name: as-get-query-viewer-results
    arguments:
    - name: id
      required: true
      description: Resource id of query viewer
    outputs:
    - contextPath: ArcSight.QueryViewerResults
      type: Unknown
      description: Query viewer results
    description: Retrieve query viewer results (query viewer must be configured to
      be refreshed every minute, see documentation)
  - name: as-fetch-incidents
    arguments:
    - name: last_run
      description: last run to start from
    description: arcsight
  isfetch: true
  runonce: false
tests:
  - ArcSight ESM Test
releaseNotes: "The integration was rewritten in python. major issues were fixed"
