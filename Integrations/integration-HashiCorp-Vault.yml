commonfields:
  id: HashiCorp Vault
  version: -1
name: HashiCorp Vault
display: HashiCorp Vault
category: Authentication
image: data:image/png;base64,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
description: Manage Secrets and Protect Sensitive Data through HashiCorp Vault
configuration:
- display: Server URL (e.g. https://192.168.0.1:8200)
  name: server
  defaultvalue: ""
  type: 0
  required: true
- display: Username
  name: credentials
  defaultvalue: ""
  type: 9
  required: false
- display: Authentication token
  name: token
  defaultvalue: ""
  type: 4
  required: false
- display: Trust any certificate (unsecure)
  name: unsecure
  defaultvalue: ""
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: ""
  type: 8
  required: false
- display: Fetches credentials
  name: isFetchCredentials
  defaultvalue: "true"
  type: 8
  required: false
- display: Comma separated secrets engines types to fetch secrets from
  name: engines
  defaultvalue: KV,Cubbyhole
  type: 0
  required: false
script:
  script: |-
    import requests
    import json
    import hcl

    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    if not demisto.params().get('proxy', False):
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']


    ''' GLOBAL VARIABLES '''

    CREDENTIALS = demisto.params().get('credentials', {})
    USERNAME = CREDENTIALS.get('identifier')
    PASSWORD = CREDENTIALS.get('password')
    VERIFY_SSL = not demisto.params().get('unsecure', False)
    TOKEN = demisto.params().get('token')

    def get_server_url():
        url = demisto.params()['server']
        url = re.sub('/[\/]+$/', '', url)
        url = re.sub('\/$', '', url)
        return url


    BASE_URL = get_server_url()
    SERVER_URL = BASE_URL + '/v1'

    ''' HELPER FUNCTIONS '''

    def get_headers():
        headers =  {
            'Content-Type': 'application/json',
        }

        if TOKEN:
            headers['X-Vault-Token'] = TOKEN

        return headers

    def login():
        path = 'auth/userpass/login/' + USERNAME
        body = {
            'password': PASSWORD
        }

        url = '{}/{}'.format(SERVER_URL, path)
        res = requests.request('POST', url, headers=get_headers(), data=json.dumps(body), verify=VERIFY_SSL)
        if res.status_code < 200 or res.status_code >= 300:
            return_error('Got status code ' + str(res.status_code) + ' with url ' + url + ' with body ' + res.content + ' with headers ' + str(res.headers))

        auth_res = res.json()
        if not auth_res or 'auth' not in auth_res or 'client_token' not in auth_res['auth']:
            return_error('Could not authenticate user')

        return auth_res['auth']['client_token']

    def send_request(path, method='get', body=None, params=None, headers=None):
        body = body if body is not None else {}
        params = params if params is not None else {}

        url = '{}/{}'.format(SERVER_URL, path)

        headers = headers if headers is not None else get_headers()
        res = requests.request(method, url, headers=headers, data=json.dumps(body), params=params, verify=VERIFY_SSL)
        if res.status_code < 200 or res.status_code >= 300:
            return_error('Got status code ' + str(res.status_code) + ' with url ' + url + ' with body ' + res.content + ' with headers ' + str(res.headers))
        if res.content:
            return res.json()
        return ''

    ''' FUNCTIONS '''

    def list_secrets_engines_command():
        res = list_secrets_engines()

        if not res:
            return_error('No engines found')

        mapped_engines = [{
            'Path': k,
            'Type': v.get('type'),
            'Description': v.get('description'),
            'Accessor': v.get('accessor')
        } for k,v in res.get('data', {}).iteritems()]

        headers = ['Path', 'Type', 'Description', 'Accessor']

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('HashiCorp Vault Secrets Engines', mapped_engines, headers=headers, removeNull=True),
            'EntryContext': {
                  'HashiCorp.Engine(val.Path===obj.Path)': createContext(mapped_engines, removeNull=True)
            }
        })

    def list_secrets_engines():
        path = 'sys/mounts'

        return send_request(path)


    def list_secrets_command():
        engine = demisto.args()['engine']

        res = list_secrets(engine)

        if not res or 'data' not in res:
            return_error('Secrets not found')

        mapped_secrets = [{
            'Name': k
        } for k in res['data'].get('keys', [])]

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('HashiCorp Vault Secrets in engine path: ' + engine, mapped_secrets, removeNull=True),
            'EntryContext': {
                  'HashiCorp.Secret(val.Name===obj.Name)': createContext(mapped_secrets)
            }
        })


    def list_secrets(engine_path):
        path = engine_path + '/metadata'

        params = {
            'list': 'true'
        }

        return send_request(path, 'get', params=params)


    def get_secret_metadata_command():
        engine_path = demisto.args()['engine_path']
        secret_path = demisto.args()['secret_path']

        res = get_secret_metadata(engine_path, secret_path)

        if not res or 'data' not in res:
            return_error('Secret not found')

        data = res['data']

        secret_headers = ['Engine','Created','Updated','CurrentVersion']
        version_headers = ['Number','Created','Deleted','Destroyed']

        mapped_secret = {
            'Path': secret_path,
            'Engine': engine_path,
            'Created': data.get('created_time'),
            'Updated': data.get('updated_time'),
            'CurrentVersion': data.get('current_version')
        }

        mapped_versions = [{
            'Number': k,
            'Created': v['created_time'],
            'Deleted': v['deletion_time'],
            'Destroyed': v['destroyed']
        } for k, v in data.get('versions', {}).iteritems()]

        hr = tableToMarkdown('Secret metadata', mapped_secret, headers=secret_headers, removeNull=True)
        if mapped_versions:
            hr += tableToMarkdown('Versions', mapped_versions, headers=version_headers, removeNull=True)
            mapped_secret['Version'] = mapped_versions

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr,
            'EntryContext': {
                  'HashiCorp.SecretMetadata(val.Path===obj.Path)': createContext(mapped_secret, removeNull=True)
            }
        })

    def get_secret_metadata(engine_path, secret_path):
        path = engine_path + '/metadata/' + secret_path

        return send_request(path, 'get')


    def delete_secret_command():
        engine_path = demisto.args()['engine_path']
        secret_path = demisto.args()['secret_path']
        versions = argToList(demisto.args()['versions'])

        res = delete_secret(engine_path, secret_path, versions)

        demisto.results('Secret versions deleted successfully')


    def delete_secret(engine_path, secret_path, versions):
        path = engine_path + 'delete/' + secret_path

        body = {
            'versions': versions
        }

        return send_request(path, 'post', body=body)

    def undelete_secret_command():
        engine_path = demisto.args()['engine_path']
        secret_path = demisto.args()['secret_path']
        versions = argToList(demisto.args()['versions'])

        res = undelete_secret(engine_path, secret_path, versions)

        demisto.results('Secret versions undeleted successfully')

    def undelete_secret(engine_path, secret_path, versions):
        path = engine_path + 'undelete/' + secret_path

        body = {
            'versions': versions
        }

        return send_request(path, 'post', body=body)

    def destroy_secret_command():
        engine_path = demisto.args()['engine_path']
        secret_path = demisto.args()['secret_path']
        versions = argToList(demisto.args()['versions'])

        res = destroy_secret(engine_path, secret_path, versions)

        demisto.results('Secret versions destroyed successfully')

    def destroy_secret(engine_path, secret_path, versions):
        path = engine_path + 'destroy/' + secret_path

        body = {
            'versions': versions
        }

        return send_request(path, 'post', body=body)


    def list_policies_command():
        res = list_policies()

        if not res or 'policies' not in res:
            return_error('No policies found')

        mapped_policies = [{
            'Name': i
        } for i in res['policies']]

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('HashiCorp Vault Policies', mapped_policies, removeNull=True),
            'EntryContext': {
                  'HashiCorp.Policy(val.Name===obj.Name)': createContext(mapped_policies, removeNull=True)
            }
        })

    def list_policies():
        path = '/sys/policy'

        return send_request(path, 'get')

    def get_policy_command():
        name = demisto.args()['name']

        res = get_policy(name)

        if not res or 'rules' not in res:
            return_error('Policy not found')

        rules = hcl.loads(res['rules'])

        mapped_rules = [{'Path': k, 'Capabilities': v['capabilities']} for k,v in rules.get('path', {}).iteritems()]

        mapped_policy = {
            'Name': res['name'],
            'Rule': mapped_rules
        }

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('HashiCorp Vault Policy - ' + name, mapped_rules, removeNull=True),
            'EntryContext': {
                  'HashiCorp.Policy(val.Name===obj.Name)': createContext(mapped_policy, removeNull=True)
            }
        })


    def get_policy(policy_name):
        path = 'sys/policy/' + policy_name

        return send_request(path, 'get')

    def disable_engine_command():
        path = demisto.args()['path']

        res = disable_engine(path)

        demisto.results('Engine disabled successfully')

    def disable_engine(engine_path):
        path = 'sys/mounts/' + engine_path

        return send_request(path, 'delete')


    def enable_engine_command():
        path = demisto.args()['path']
        engine_type = demisto.args()['type']
        description = demisto.args().get('description')
        default_lease_ttl = demisto.args().get('default_lease_ttl')
        max_lease_ttl = demisto.args().get('max_lease_ttl')
        force_no_cache = demisto.args().get('force_no_cache')
        audit_non_hmac_request_keys = demisto.args().get('audit_non_hmac_request_keys')
        audit_non_hmac_response_keys = demisto.args().get('audit_non_hmac_response_keys')
        listing_visibility = demisto.args().get('listing_visibility')
        passthrough_request_headers = demisto.args().get('passthrough_request_headers')
        kv_version = demisto.args().get('kv_version')
        local = demisto.args().get('local')
        seal_wrap = demisto.args().get('seal_wrap')

        res = enable_engine(path, engine_type, description, default_lease_ttl, max_lease_ttl, force_no_cache, audit_non_hmac_request_keys,
                      audit_non_hmac_response_keys, listing_visibility, passthrough_request_headers, kv_version, local, seal_wrap)

        demisto.results('Engine enabled successfully')

    def enable_engine(path, engine_type, description, default_lease_ttl, max_lease_ttl, force_no_cache, audit_non_hmac_request_keys,
                      audit_non_hmac_response_keys, listing_visibility, passthrough_request_headers, kv_version, local, seal_wrap):
            path = 'sys/mounts/' + path

            body = {
                'type': engine_type,
                'config': {}
            }
            if description:
                body['description'] = description

            if default_lease_ttl:
                body['config']['default_lease_ttl'] = default_lease_ttl
            if max_lease_ttl:
                body['config']['max_lease_ttl'] = max_lease_ttl
            if force_no_cache:
                body['config']['force_no_cache'] = force_no_cache
            if audit_non_hmac_request_keys:
                body['config']['audit_non_hmac_request_keys'] = audit_non_hmac_request_keys
            if audit_non_hmac_response_keys:
                body['config']['audit_non_hmac_response_keys'] = audit_non_hmac_response_keys
            if listing_visibility:
                body['config']['listing_visibility'] = listing_visibility
            if passthrough_request_headers:
                body['config']['passthrough_request_headers'] = passthrough_request_headers
            if kv_version:
                body['options'] = {
                    'version': kv_version
                }
            if local:
                body['local'] = local
            if seal_wrap:
                body['seal_wrap'] = seal_wrap

            if not body['config']:
                del body['config']

            return send_request(path, 'post', body=body)


    def seal_vault_command():
        res = seal_vault()

        demisto.results('Vault sealed successfully')


    def seal_vault():
        path = 'sys/seal'

        return send_request(path, 'put')


    def unseal_vault_command():
        reset = demisto.args().get('reset')
        key = demisto.args().get('key')

        if not key and not reset:
            return_error('Either key or reset must be provided')

        res = unseal_vault(key, reset)

        if not res:
            return_error('Could not retrieve unseal state')

        headers = ['Sealed', 'Threshold', 'Shares', 'Progress']

        mapped_unseal = {
            'Sealed': res.get('sealed'),
            'Threshold': res.get('t'),
            'Shares': res.get('n'),
            'Progress': res.get('progress')
        }

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('HashiCorp Vault Unseal', mapped_unseal, removeNull=True),
            'EntryContext': {
                  'HashiCorp.Unseal(val.Sealed===obj.Sealed)': createContext(mapped_unseal, removeNull=True)
            }
        })


    def unseal_vault(key, reset):
        body = {}
        if reset:
            body['reset'] = reset
        elif key:
            body['key'] = key

        return send_request(path, 'put', body=body)


    def create_token_command():
        role_name = demisto.args().get('role_name')
        policies = argToList(demisto.args().get('policies', []))
        meta = demisto.args().get('meta')
        no_parent = demisto.args().get('no_parent')
        no_default_policy = demisto.args().get('no_default_policy')
        renewable = demisto.args().get('renewable')
        ttl = demisto.args().get('ttl')
        explicit_max_ttl = demisto.args().get('explicit_max_ttl')
        display_name = demisto.args().get('display_name')
        num_uses = demisto.args().get('num_uses')
        period = demisto.args().get('period')

        res = create_token(role_name, policies, meta, no_parent, no_default_policy, renewable, ttl, explicit_max_ttl,
                    display_name, num_uses, period)

        if not res or 'auth' not in res:
            return_error('Could not get authentication token')

        auth = res['auth']

        headers = ['Token', 'Policy', 'LeaseDuration']

        mapped_auth = {
            'Token': auth.get('client_token'),
            'Policy': auth.get('policies'),
            'LeaseDuration': auth.get('lease_duration')
        }

        demisto.results({
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Token successfully created', mapped_auth, removeNull=True),
            'EntryContext': {
                  'HashiCorp.Auth(val.Token===obj.Token)': createContext(mapped_auth, removeNull=True)
            }
        })


    def create_token(role_name, policies, meta, no_parent, no_default_policy, renewable, ttl, explicit_max_ttl,
                    display_name, num_uses, period):
        path = 'auth/token/create'
        body = {}
        if role_name:
            body['role_name'] = role_name
        if policies:
            body['policies'] = policies
        if meta:
            body['meta'] = meta
        if no_parent:
            body['no_parent'] = no_parent
        if no_default_policy:
            body['no_default_policy'] = no_default_policy
        if renewable:
            body['renewable'] = renewable
        if ttl:
            body['ttl'] = ttl
        if explicit_max_ttl:
            body['explicit_max_ttl'] = explicit_max_ttl
        if display_name:
            body['display_name'] = display_name
        if num_uses:
            body['num_uses'] = num_uses
        if period:
            body['period'] = period

        return send_request(path, 'post', body=body)

    def configure_engine_command():
        engine_path = demisto.args()['path']
        engine_type = demisto.args()['type']
        version = demisto.args().get('version')

        configure_engine(engine_path, engine_type, version)

        demisto.results('Engine configured successfully')

    def reset_config_command():
        demisto.setIntegrationContext({'configs': []})

        demisto.results('Successfully reset the engines configuration')

    def configure_engine(engine_path, engine_type, version):
        engine_conf = {
            'type': engine_type,
            'path': engine_path
        }
        if version:
            engine_conf['version'] = str(version)

        ENGINE_CONFIGS.append(engine_conf)

        demisto.setIntegrationContext({'configs': ENGINE_CONFIGS})


    def fetch_credentials():
        credentials = []
        engines_to_fetch_from = []
        ENGINES = argToList(demisto.params().get('engines', []))
        if not isinstance(ENGINES, list):
            ENGINES = [ENGINES]

        if len(ENGINES) == 0:
            return_error('No secrets engines specified')

        for engine_type in ENGINES:
            engines_to_fetch = list(filter(lambda e: e['type'] == engine_type, ENGINE_CONFIGS))
            if len(engines_to_fetch) == 0:
                return_error('Engine type not configured')
            engines_to_fetch_from += engines_to_fetch

        for engine in engines_to_fetch_from:
            if engine['type'] == 'KV':
                if engine['version'] == '1':
                    credentials += get_kv1_secrets(engine['path'])
                elif engine['version'] == '2':
                    credentials += get_kv2_secrets(engine['path'])
            elif engine['type'] == 'Cubbyhole':
                credentials += get_ch_secrets(engine['path'])

        demisto.credentials(credentials)


    def get_kv1_secrets(engine_path):
        path = engine_path
        params = {
            'list': 'true'
        }

        res = send_request(path, 'get', params=params)

        secrets = []

        if not res or 'data' not in res:
            return []

        for secret in res['data'].get('keys', []):
            secret_data = get_kv1_secret(engine_path, secret)
            for k,v in secret_data.get('data', {}).iteritems():
                secrets.append({
                        'user': k,
                        'password': v,
                        'name': secret
                    })

        return secrets

    def get_kv1_secret(engine_path, secret):
        path = engine_path + secret

        return send_request(path, 'get')

    def get_kv2_secrets(engine_path):
        secrets = []
        res = list_secrets(engine_path)
        if not res or 'data' not in res:
            return []

        for secret in res['data'].get('keys', []):
            secret_data = get_kv2_secret(engine_path, secret)
            for k,v in secret_data.get('data', {}).get('data', {}).iteritems():
                secrets.append({
                        'user': k,
                        'password': v,
                        'name': secret
                    })

        return secrets

    def get_kv2_secret(engine_path, secret):
        path = engine_path + 'data/' + secret

        return send_request(path, 'get')


    def get_ch_secrets(engine_path):
        path = engine_path

        params = {
            'list': 'true'
        }

        res = send_request(path, 'get', params=params)

        secrets = []

        if not res or 'data' not in res:
            return []

        for secret in res['data'].get('keys', []):
            secret_data = get_ch_secret(engine_path, secret)
            for k,v in secret_data.get('data', {}).iteritems():
                secrets.append({
                        'user': k,
                        'password': v,
                        'name': secret
                    })

        return secrets

    def get_ch_secret(engine_path, secret):
        path = engine_path + secret

        return send_request(path, 'get')

    ''' EXECUTION CODE '''

    if USERNAME and PASSWORD:
        TOKEN = login()
    elif not TOKEN:
        return_error('Either an authentication token or user credentials must be provided')

    integ_context = demisto.getIntegrationContext()
    if not integ_context or 'configs' not in integ_context:
        integ_context['configs'] = []

    ENGINE_CONFIGS = integ_context['configs']

    if demisto.command() == 'test-module':
        path = 'sys/health'
        send_request(path)
        demisto.results('ok')
    elif demisto.command() == 'fetch-credentials':
        fetch_credentials()
    elif demisto.command() == 'hashicorp-list-secrets-engines':
        list_secrets_engines_command()
    elif demisto.command() == 'hashicorp-list-secrets':
        list_secrets_command()
    elif demisto.command() == 'hashicorp-list-policies':
        list_policies_command()
    elif demisto.command() == 'hashicorp-get-policy':
        get_policy_command()
    elif demisto.command() == 'hashicorp-get-secret-metadata':
        get_secret_metadata_command()
    elif demisto.command() == 'hashicorp-delete-secret':
        delete_secret_command()
    elif demisto.command() == 'hashicorp-undelete-secret':
        undelete_secret_command()
    elif demisto.command() == 'hashicorp-destroy-secret':
        destroy_secret_command()
    elif demisto.command() == 'hashicorp-disable-engine':
        disable_engine_command()
    elif demisto.command() == 'hashicorp-enable-engine':
        enable_engine_command()
    elif demisto.command() == 'seal_vault_command':
        seal_vault_command()
    elif demisto.command() == 'unseal_vault_command':
        unseal_vault_command()
    elif demisto.command() == 'hashicorp-create-token':
        create_token_command()
    elif demisto.command() == 'hashicorp-configure-engine':
        configure_engine_command()
    elif demisto.command() == 'hashicorp-reset-configuration':
        reset_config_command()
  type: python
  commands:
  - name: hashicorp-list-secrets-engines
    arguments: []
    outputs:
    - contextPath: HashiCorp.Engine.Type
      description: Secrets engine type
      type: string
    - contextPath: HashiCorp.Engine.Path
      description: Secrets engine path in HashiCorp
      type: string
    - contextPath: HashiCorp.Engine.Description
      description: Secrets engine description
      type: string
    - contextPath: HashiCorp.Engine.Accessor
      description: Secrets engine accessor
      type: string
    description: List all secrets engines that exist in HashiCorp Vault.
  - name: hashicorp-get-secret-metadata
    arguments:
    - name: engine_path
      required: true
      description: KV Engine path (engine path - for example - /kv)
    - name: secret_path
      required: true
      description: Secret path
    outputs:
    - contextPath: HashiCorp.Secret.Created
      description: Secret created time
      type: date
    - contextPath: HashiCorp.Secret.Version.Destroyed
      description: Whether the version is destroyed
      type: boolean
    - contextPath: HashiCorp.Secret.Version.Created
      description: Version creation time
      type: number
    - contextPath: HashiCorp.Secret.Version.Deleted
      description: Version deletion time
      type: date
    - contextPath: HashiCorp.Secret.Updated
      description: Secret last updated time
      type: date
    - contextPath: HashiCorp.Secret.Engine
      description: Secret engine type
      type: string
    - contextPath: HashiCorp.Secret.CurrentVersion
      description: Secret current version
    - contextPath: HashiCorp.Secret.Path
      description: Secret path
    description: Get information about a specified secret in a specified K/V V2 engine
  - name: hashicorp-list-secrets
    arguments:
    - name: engine
      required: true
      default: true
      description: Engine path (for example - secret/), retrieve from list-secrets-engines
        command.
    outputs:
    - contextPath: HashiCorp.Secret.Name
      description: Secret name
      type: string
    - contextPath: HashiCorp.Secret.Path
      description: Secrets engine path in HashiCorp
      type: string
    - contextPath: HashiCorp.Secret.Engine
      description: Secrets engine type
      type: string
    description: List secrets (names) for a specified K/V V2 engine
  - name: hashicorp-delete-secret
    arguments:
    - name: secret_path
      required: true
      description: Secret path
    - name: engine_path
      required: true
      description: Engine path (engine path - for example - secret/)
    - name: versions
      required: true
      description: Comma separated secret versions to delete
      isArray: true
    description: Delete the data under a specified secret given the secret path. Performs
      a soft delete that allows the undelete command if necessary (for KV engine version
      2)
  - name: hashicorp-undelete-secret
    arguments:
    - name: secret_path
      required: true
      description: Secret path
    - name: engine_path
      required: true
      description: Engine path - for example - secret/
    - name: versions
      required: true
      description: Comma separated secret versions
      isArray: true
    description: Undelete a secret on HashiCorp (for K/V engine version 2)
  - name: hashicorp-destroy-secret
    arguments:
    - name: secret_path
      required: true
      description: Secret path
    - name: engine_path
      required: true
      description: Engine path - for example - secret/
    - name: versions
      required: true
      description: Comma separated secret versions to delete
      isArray: true
    description: Delete a secret permanently (for K/V engine version 2)
  - name: hashicorp-disable-engine
    arguments:
    - name: path
      required: true
      default: true
      description: Secrets engine path
    description: When a secrets engine is no longer needed, it can be disabled. All
      secrets under the engine are revoked and the corresponding Vault data and configuration
      is removed.
  - name: hashicorp-list-policies
    arguments: []
    outputs:
    - contextPath: HashiCorp.Policy.Name
      description: Policy name
      type: string
    description: List all configured policies.
  - name: hashicorp-seal-vault
    arguments: []
    description: If you suspect your data has been compromised, you can seal your
      vault to prevent access to your secrets
    execution: true
  - name: hashicorp-unseal-vault
    arguments:
    - name: key
      description: 'Single master key '
    - name: reset
      auto: PREDEFINED
      predefined:
      - "true"
      description: Reset the unseal project
    outputs:
    - contextPath: HashiCorp.Unseal.Sealed
      description: Whether the vault is sealed
      type: boolean
    - contextPath: HashiCorp.Unseal.Threshold
      description: Vault unseal threshold
      type: number
    - contextPath: HashiCorp.Unseal.Shares
      description: Vault unseal shares
      type: number
    - contextPath: HashiCorp.Unseal.Progress
      description: Unseal progress
      type: number
    description: Use a single master key share to progress the unsealing of the Vault.
      If the threshold number of master key shares is reached, Vault will attempt
      to unseal the Vault. Otherwise, this API must be called multiple times until
      that threshold is met.
  - name: hashicorp-create-token
    arguments:
    - name: role_name
      description: The name of the token role.
    - name: policies
      description: A comma separated list of policies for the token. This must be
        a subset of the policies belonging to the token making the request, unless
        root. If not specified, defaults to all the policies of the calling token.
      isArray: true
    - name: meta
      description: A map of string to string valued metadata. This is passed through
        to the audit devices.
    - name: no_parent
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: If true and set by a root caller, the token will not have the parent
        token of the caller. This creates a token with no parent.
    - name: no_default_policy
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: ' If true the default policy will not be contained in this token''s
        policy set.'
    - name: renewable
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Set to false to disable the ability of the token to be renewed
        past its initial TTL. Setting the value to true will allow the token to be
        renewable up to the system/mount maximum TTL.
    - name: ttl
      description: The TTL(lease duration) period of the token, provided as "1h",
        where hour is the largest suffix. If not provided, the token is valid for
        the default lease TTL, or indefinitely if the root policy is used.
    - name: explicit_max_ttl
      description: ' If set, the token will have an explicit max TTL set upon it.
        This maximum token TTL cannot be changed later, and unlike with normal tokens,
        updates to the system/mount max TTL value will have no effect at renewal time
        -- the token will never be able to be renewed or used past the value set at
        issue time.'
    - name: display_name
      description: The display name of the token.
    - name: num_uses
      description: The maximum uses for the given token. This can be used to create
        a one-time-token or limited use token. The value of 0 has no limit to the
        number of uses.
    - name: period
      description: If specified, the token will be periodic; it will have no maximum
        TTL (unless an "explicit-max-ttl" is also set) but every renewal will use
        the given period. Requires a root/sudo token to use.
    outputs:
    - contextPath: HashiCorp.Auth.Token
      description: Authentication token
      type: string
    - contextPath: HashiCorp.Auth.Policy
      description: Authentication policies
    - contextPath: HashiCorp.Auth.LeaseDuration
      description: 'Authentication lease duration in seconds, 0 if indefinitely '
      type: number
    description: Create a new token.
  - name: hashicorp-get-policy
    arguments:
    - name: name
      required: true
      description: Policy name
    outputs:
    - contextPath: HashiCorp.Policy.Name
      description: Policy name
      type: string
    - contextPath: 'HashiCorp.Policy.Rule.Path '
      description: Policy rule path
      type: string
    - contextPath: HashiCorp.Policy.Rule.Capabilities
      description: Policy rule capabilities
    description: Get a policy with a specified name
  - name: hashicorp-enable-engine
    arguments:
    - name: path
      required: true
      description: The path where the secrets engine will be mounted.
    - name: type
      required: true
      description: Type of the backend, e.g. "aws".
    - name: description
      description: Human-friendly description of the mount.
    - name: default_lease_ttl
      description: The default lease duration, specified as a string duration like
                     "5s" or "30m".
    - name: max_lease_ttl
      description: The maximum lease duration, specified as a string duration like
                     "5s" or "30m".
    - name: force_no_cache
      description: Disable caching.
    - name: audit_non_hmac_request_keys
      description: Comma-separated list of keys that will not be HMAC'd by audit devices
        in the request data object.
      isArray: true
    - name: audit_non_hmac_response_keys
      description: Comma-separated list of keys that will not be HMAC'd by audit devices
        in the response data object.
      isArray: true
    - name: listing_visibility
      auto: PREDEFINED
      predefined:
      - unauth
      - hidden
      description: Whether to show this mount in the UI-specific listing endpoint.
        Default is hidden.
    - name: passthrough_request_headers
      description: Comma-separated list of headers to whitelist and pass from the
        request to the backend.
      isArray: true
    - name: kv_version
      description: The version of the KV to mount. Set to "2" for mount KV v2.
    - name: local
      description: Specifies if the secrets engine is a local mount only. Local mounts
        are not replicated nor (if a secondary) removed by replication. Supported
        only in Vault Enterprise.
    - name: seal_wrap
      description: Enable seal wrapping for the mount. Supported only in Vault Enterprise.
    description: Enable a new secrets engine at the given path.
  - name: hashicorp-configure-engine
    arguments:
    - name: path
      required: true
      description: The engine path, e.g. secret/
    - name: type
      required: true
      description: The engine type, e.g. KV
    - name: version
      auto: PREDEFINED
      predefined:
      - "1"
      - "2"
      description: The engine version (for KV engines)
    description: Configure a secrets engine to fetch secrets from.
  - name: hashicorp-reset-configuration
    arguments: []
    description: Reset the engines configuration
  dockerimage: blob
  runonce: false
