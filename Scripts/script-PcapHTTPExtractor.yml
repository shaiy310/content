args:
- default: false
  defaultValue: ''
  description: get file entry from file name
  isArray: false
  name: pcapFileName
  predefined: []
  required: false
  secret: false
- default: true
  defaultValue: ''
  description: File entry from the WarRoom
  isArray: false
  name: entryID
  predefined: []
  required: false
  secret: false
- default: false
  defaultValue: '50'
  description: Limit the output of the capture file output's flows.
  isArray: false
  name: limit
  predefined: []
  required: false
  secret: false
- default: false
  defaultValue: '0'
  description: Index of where to output flows.
  isArray: false
  name: start
  predefined: []
  required: false
  secret: false
- default: false
  defaultValue: '512'
  description: "Limit the HttpFileData field (in bytes)\t\t"
  isArray: false
  name: limitData
  predefined: []
  required: false
  secret: false
- default: false
  defaultValue: ''
  description: The allowed content types to output from the capture file.
  isArray: false
  name: allowedContentTypes
  predefined: []
  required: false
  secret: false
comment: Allows to parse and extract http flows from a pcap/pcapng file.
commonfields: {id: PcapHTTPExtractor, version: -1}
enabled: true
name: PcapHTTPExtractor
outputs:
- {contextPath: PcapHTTPFlows, description: Flows extracted from the pcap file., type: String}
- {contextPath: PcapHttpFlows.ResultIndex, description: The index of the http packet
    in the pcap file., type: String}
- {contextPath: PcapHttpFlows.HttpContentType, description: Http content type of the
    response., type: String}
- {contextPath: PcapHttpFlows.HttpResponseVersion, description: Http version used
    in the response., type: String}
- {contextPath: PcapHttpFlows.HttpResponseCode, description: Http response code from
    the server, type: String}
- {contextPath: PcapHttpFlows.HttpDate, description: Http date returned from the sever,
  type: String}
- {contextPath: PcapHttpFlows.HttpRequestMethod, description: Http request method
    used., type: String}
- {contextPath: PcapHttpFlows.HttpRequestUri, description: Http request URI (path),
  type: String}
- {contextPath: PcapHttpFlows.HttpFileData, description: Http content of the response,
  type: String}
- {contextPath: PcapHttpFlows.HttpServer, description: The server signature in the
    response, type: String}
- {contextPath: PcapHttpFlows.HttpUserAgent, description: Http user agent sent in
    the request, type: String}
- {contextPath: PcapHttpFlows.HttpAccept, description: Http request accept type, type: String}
script: |-
  import pyshark
  from datetime import datetime


  def file_has_extension(file_name, extensions):
      """
      Check if a file name has an extension.
      Returns true/false

      :param file_name: the file name to check against.
      :param extensions: extensions to test if exists in file_name.
      :return: True if one of the extensions is in the file_name
      """
      for ext in extensions:
          if file_name.endswith(ext):
              return True

      return False


  def find_entry_id_by_name(file_name, extensions=None):
      """
      Scan all entries and find corresponding entry id by file name
      extensions, an array used to furthur filter the entries.

      :param file_name: find by file name.
      :param extensions:  filter more by the file extension.
      :return: the found entryID
      """
      entries = demisto.executeCommand('getEntries', {})
      found_entry_id = None
      for entry in entries:
          entry_file_name = demisto.get(entry, 'File')
          is_correct_file = file_name.lower() == entry_file_name.lower()
          has_correct_extension = file_has_extension(file_name, extensions) if extensions else True

          if is_correct_file and has_correct_extension:
              found_entry_id = entry['ID']
              break

      if not found_entry_id:
          demisto.results({"Type": entryTypes["note"],
                           "ContentsFormat": formats["markdown"],
                           "Contents": "### No file found",
                           "EntryContext": {"PcapHTTPExtractor.Flows": []}
                           })
          sys.exit(0)

      return found_entry_id


  def get_entry_from_args():
      """
          Handle finding the file entry using the user supplied arguments
           return the entry or quits script entirely.

          :rtype: object containing the entry of the found file and the entry_id or error & exit
      """
      # Get the pcap file from arguments
      entry_id = None
      if 'pcapFileName' in demisto.args() \
              and 'entryID' not in demisto.args():

          PCAP_FILE = demisto.args()["pcapFileName"]
          entry_id = find_entry_id_by_name(PCAP_FILE, [".pcap", ".cap", ".pcapng"])
      elif 'entryID' in demisto.args():
          entry_id = demisto.args()["entryID"]
      else:
          return_error('You must set pcapFileName or entryID when executing PcapHTTPExtract script')

      res = demisto.executeCommand('getFilePath', {'id': entry_id})

      if len(res) > 0 and res[0]['Type'] == entryTypes['error']:
          return_error('Failed to get the file path for entry: ' + entry_id)

      return res, entry_id


  def parse_capture_dict(capture_object):
      """
          Parse a capture object into a readable http dict
              Added tcp information
          :param capture_object: the pyshark capture object from file
          :return: a pythonic dict of result
      """
      try:
          http_object_tshark = capture_object.http.__dict__["_all_fields"]
          tcp_object_tshark = capture_object.tcp.__dict__["_all_fields"]
          ip_object_tshark = capture_object.ip.__dict__["_all_fields"]
      except KeyError:
          return_error('No readable result')
          sys.exit(0)

      # Remove unecessary attributes of the object
      blacklist_keys = ["_ws", "http.content_length_header",
                        "http.cookie_pair", "http.response.phrase"]

      for bk in blacklist_keys:
          http_object_tshark = {k: v for k, v in http_object_tshark.items() if not k.startswith(bk)}

      if "" in http_object_tshark:
          del http_object_tshark[""]  # Some empty key that is a duplicate

      # Concatenate the tcp & ip information
      http_object_tshark.update({"tcp.src_port": tcp_object_tshark["tcp.srcport"]})
      http_object_tshark.update({"tcp.dst_port": tcp_object_tshark["tcp.dstport"]})
      http_object_tshark.update({"ip.src": ip_object_tshark["ip.src"]})
      http_object_tshark.update({"ip.dst": ip_object_tshark["ip.dst"]})


      return http_object_tshark


  def get_pcap_dict(pcap_file_path):
      """
          By deafult returns a dict of the results.
          Will return and exit if no http flows found

          :param pcap_file_path: local path of file (after getting the entryID)
          :return: return all http packets in a list
      """

      packets = pyshark.FileCapture(pcap_file_path)
      http_packets = []

      for packet in packets:

          # Check if this is an HTTP Packet
          if 'http' in packet:
              packet = parse_capture_dict(packet)
              http_packets.append(packet)

      if len(http_packets) == 0:
          return_error('No HTTP flows found in specified file.')
          sys.exit(0)

      return http_packets


  def trim_limit_data(http_flows, limit_data_size):
      for flow in http_flows:
          if "http.file_data" in flow and \
                  len(flow["http.file_data"]) > limit_data_size:
              flow["http.file_data"] = "[TRIMMED] - {}...".format(
                  flow["http.file_data"][:limit_data_size])


      return http_flows


  def markdown_packets(http_flows):
      """
          Convert a json list of packets into a markdown table

          :param http_flows: a list of http packets
          :return: a string of markdown
      """
      result_nobody_template = "---\n{res}\n---"
      markdown_result = ""

      for i, packet in enumerate(http_flows):
          row = result_nobody_template.format(
              res=tableToMarkdown("HTTP #{}".format(i + 1),
                                  packet,
                                  packet.keys()
                                  )
          )
          markdown_result += row

      return markdown_result


  def _fix_key(keys_list):
      """
      Fix the key to abide the context
      :param keys_list:
      :return:
      """
      key_name = ""
      for k in keys_list:
          if "_" in k:
              key_name += _fix_key(k.split("_"))
          else:
              key_name += k.capitalize()

      return key_name


  def fix_output(http_flows, context_filter=False, allowed_content_types=[]):
      """
      Fixes the http_flows's keys to abide the Demisto conventions.
      :param context_filter: if True will strip down more keys for a slimmer context output.
      :param http_flows: a list of http packets
      :return: the object containing all of the filtered and formatted flows.
      """

      relevant_context = [
                          # HTTP
                          "http.host", "http.user_agent", "http.response.code",
                          "http.response.version", "http.date", "http.last_modified",
                          "http.request.uri", "http.request.full_uri",
                          "http.request.method", "http.file_data", "http.accept",
                          "http.content_type", "http.server",
                          # IP
                          "ip.src",
                          "ip.dst",
                          # TCP
                          "tcp.src_port",
                          "tcp.dst_port",
                          ]

      extra_keys = ["http.content_length", "http.request", "http.response.phrase", "http.chat"]

      if not context_filter:
          relevant_context += extra_keys

      if len(allowed_content_types) == 0:
          allowed_content_types = ("text", "application/json", "multipart/form-data",
                               "application/xml", "application/xhtml+xml",
                               "application/ld+json", "application/javascript",
                               "multipart/alternative", "application/x-www-form-urlencoded")
      else:
          allowed_content_types = tuple(allowed_content_types.split(","))

      context_list = []
      flow_index = 0
      for flow in http_flows:
          flow_index += 1
          cd = {"ResultIndex": flow_index}

          cd.update({_fix_key(k.split(".")): v for k, v in flow.items() if k in relevant_context})

          # Fix the chat file newline
          if "HttpChat" in cd:
              cd["HttpChat"] = cd["HttpChat"].replace("\\r\\n", "")

          # Convert to ISO time
          if "HttpDate" in cd:
              cd['HttpDate'] = datetime.strptime(cd['HttpDate'], '%a, %d %b %Y %H:%M:%S %Z').isoformat()

          # Allow only whitelist of content
          if "HttpContentType" in cd:
              if not cd["HttpContentType"].startswith(allowed_content_types):
                  if "HttpFileData" in cd and len(cd["HttpFileData"]) > 0:
                      cd["HttpFileData"] = "Unsupported content type."

          context_list.append(cd)

      return context_list


  if __name__ == "builtins":
      try:
          # Parse the arguments
          pcap_file_path_in_container, pcap_entry_id = get_entry_from_args()
          pcap_file_path_in_container = pcap_file_path_in_container[0]['Contents']['path']
          LIMIT = demisto.args()["limit"]
          START = demisto.args()["start"]
          LIMIT_DATA = int(demisto.args()["limitData"])

          if "allowedContentTypes" not in demisto.args():
              ALLOWED_CONTENT_TYPES = ()
          else:
              ALLOWED_CONTENT_TYPES = demisto.args()["allowedContentTypes"]

          # Work on the pcap file and return a result
          http_flows = get_pcap_dict(pcap_file_path_in_container)

          # Cut results according to the user args.
          if START:
              http_flows = http_flows[int(START):]
          if LIMIT:
              http_flows = http_flows[:int(LIMIT)]
          if LIMIT_DATA:
              http_flows = trim_limit_data(http_flows, LIMIT_DATA)

          http_flows_fixed = fix_output(http_flows, allowed_content_types=ALLOWED_CONTENT_TYPES)
          markdown_results = markdown_packets(http_flows_fixed)

          demisto.results({"Type": entryTypes["note"],
                           "ContentsFormat": formats["markdown"],
                           "Contents": markdown_results,
                           "EntryContext": {"PcapHTTPFlows": fix_output(http_flows, context_filter=True,
                                                                        allowed_content_types=ALLOWED_CONTENT_TYPES)}
                           })

      except Exception as ex:
          import traceback

          return_error("Error occurred while parsing output from command. Exception info:\n"
                       + str(ex) + "\n\nTrace:\n" + str(traceback.format_exc()))
system: false
tags: [pcap, http]
timeout: '0'
type: python
dockerimage: demisto/pcap-http-extractor:1.0.0.98
releaseNotes: Adding a new script that allows to extract http flows from pcap/pcapng
  files.
tests: [Test-PcapHTTPExtractor]
