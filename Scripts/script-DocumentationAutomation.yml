commonfields:
  id: DocumentationAutomation
  version: -1
name: DocumentationAutomation
script: |-
  import yaml
  import sys

  reload(sys)
  sys.setdefaultencoding('utf-8')

  def get_yaml_obj(entry_id):
      yml_file_path = demisto.getFilePath(entry_id)['path']
      with open(yml_file_path, 'r') as yml_file:
          data = yaml.safe_load(yml_file)

      return data


  def get_command_examples(entry_id):
      if entry_id is None:
          return []

      examples_path = demisto.getFilePath(entry_id)['path']
      with open(examples_path, 'r') as examples_file:
          data = examples_file.read().split('\n')

      return data


  def find_cmd_example(command_examples, cmd):
      valid_examples = [example for example in command_examples
          if example.startswith(cmd) or example.startswith('!{}'.format(cmd))]

      return valid_examples[0] if len(valid_examples) > 0 else ' '


  def extract_command(cmd_example):
      parts = cmd_example.split(' ')

      return parts[0], dict([p.replace('"', '').split('=') for p in parts[1:]])


  def generate_command_example(cmd, cmd_example):
      context_example = ''
      md_example = ''
      if cmd_example != ' ':
          try:
              example_cmd, kwargs = extract_command(cmd_example)
              res = demisto.executeCommand(example_cmd, kwargs)

              for entry in res:
                  if isError(entry):
                      demisto.results(res)
                      raise RuntimeError('something went wrong with your command.')

              raw_context = entry.get('EntryContext')
              context = {k.split('(')[0] : v for k, v in raw_context.items()}

              context_example = json.dumps(context, indent=4)
              md_example = entry.get('HumanReadable', json.dumps(entry['Contents']))

          except RuntimeError as e:
              demisto.results("The provided example for cmd {} has failed...".format(cmd['name']))
              demisto.results(res)
          except Exception as e:
              demisto.results('Error encountered in the processing of command {}, error was: {}'.format(cmd['name'], str(e)) +
                  ". Please check your command inputs and outputs")
      else:
          demisto.results('did not get any example for {}. please add it manually.'.format(cmd['name']))

      example = [
          '',
          '##### Command Example',
          '`{}`'.format(cmd_example),
          '',
          '##### Context Example',
          '```',
          '{}'.format(context_example),
          '```',
          '',
          '##### Human Readable Output',
          '{}'.format(md_example),
          '',
          ]
      return example


  def addLines(line):
      output = []
      lastDigit = 0
      for i in range(len(line)):
          if line[i].isdigit():
              if line[i+1] == '.':
                  output.append(line[lastDigit:i])
                  lastDigit = i
      output.append(line[lastDigit:len(line)])

      return output


  def addErrorLines(scriptToScan, scriptType):
      res = ''
      if 'python' in scriptType:
          errorKeys = ['return_error', 'raise ']
      elif 'javascript' in scriptType:
          errorKeys = ['throw ']
      # Unsupported script type
      else:
          return res
      linesToSkip = 0
      scriptLines = scriptToScan.splitlines()
      for idx in range(len(scriptLines)):
          # Skip lines that were already scanned
          if linesToSkip > 0:
              linesToSkip -= 1
              continue
          line = scriptLines[idx]
          if any(key in line for key in errorKeys):
              if '(' in line:
                  bracketOpenIdx = line.index('(') + 1
                  if ')' in line:
                      bracketCloseIdx = line.index(')')
                      res += '* ' + line[bracketOpenIdx:bracketCloseIdx] + '\n'
                  # Handle multi line error
                  else:
                      res += '*' + ('' if len(line[bracketOpenIdx:].lstrip()) < 1 else ' ' + line[bracketOpenIdx:] + '\n')
                      while not ')' in scriptLines[idx + linesToSkip + 1]:
                          linesToSkip += 1
                          line = scriptLines[idx + linesToSkip]
                          res += ' ' + line.lstrip() + '\n'
                      # Adding last line of error
                      linesToSkip += 1
                      line = scriptLines[idx + linesToSkip]
                      bracketCloseIdx = line.index(')')
                      res += line[:bracketCloseIdx].lstrip() + '\n'
              else:
                  firstMatchingErrorKey = next((key for key in errorKeys if key in line), False)
                  afterErrorKeyIdx = line.index(firstMatchingErrorKey) + len(firstMatchingErrorKey)
                  res += '* ' + line[afterErrorKeyIdx:] + '\n'
      return res


  def generate_section(title, data):
      section = [
          '## {}'.format(title),
          '---',
          '',
      ]

      if data is not None:
          section.append(addLines(data))

      return section


  #Setup integration on Demisto
  def generate_setup_section(yaml_data):
      section = [
          '1. Navigate to __Settings__ > __Integrations__ > __Servers & Services__.',
          '2. Search for {}.'.format(yaml_data['name']),
          '3. Click __Add instance__ to create and configure a new integration instance.',
          '    * __Name__: a textual name for the integration instance.',
      ]
      for conf in yaml_data['configuration']:
          if conf['display']:
              section.append('    * __{}__'.format(conf['display']))
          else:
              section.append('    * __{}__'.format(conf['name']))
      section.append('4. Click __Test__ to validate the URLs, token, and connection.')

      return section


  # Commands
  def generate_commands_section(yaml_data, command_examples):
      section = [
          '## Commands',
          '---',
          'You can execute these commands from the Demisto CLI, as part of an automation, or in a playbook.',
          'After you successfully execute a command, a DBot message appears in the War Room with the command details.'
      ]
      commands = yaml_data['script']['commands']
      command_list = ['{}. {}'.format(i + 1, cmd['name']) for i, cmd in enumerate(commands)]
      section.extend(command_list)

      for i, cmd in enumerate(commands):
          section.extend(generate_single_command_section(i, cmd, find_cmd_example(command_examples, cmd['name'])))

      return section


  def generate_single_command_section(index, cmd, cmd_example):
      section = [
          '### {}'.format(cmd['name']),
          '---',
          cmd.get('description', ' '),
          '##### Base Command',
          '',
          '`{}`'.format(cmd['name']),
          '##### Input',
          '',
      ]

      #Inputs
      if len(cmd['arguments']) == 0:
          section.append('There are no input arguments for this command.')
      else:
          section.extend([
              '| **Argument Name** | **Description** | **Required** |',
              '| --- | --- | --- |',
          ])
          for arg in cmd['arguments']:
              if not arg.get('description'):
                  demisto.results('Error! You are missing description in input {} of command {}'.format(arg['name'], cmd['name']))
              required_status = 'Required' if arg.get('required') == True else 'Optional'
              section.append('| {} | {} | {} | '.format(arg['name'], arg['description'], required_status))
          section.append('')

      #Context output
      section.extend([
          '',
          '##### Context Output',
          '',
      ])
      outputs = cmd.get('outputs')
      if outputs is None:
          section.append('There is no context output for this command.')
      else:
          section.extend([
              '| **Path** | **Type** | **Description** |',
              '| --- | --- | --- |'
          ])
          for output in outputs:
              if not output.get('description'):
                  demisto.results('Error! You are missing description in output {} of command {}'.format(output['name'], cmd['name']))
              section.append('| {} | {} | {} | '.format(output['contextPath'], output.get('type', 'unknown'), output['description']))
          section.append('')

      #Raw output:
      section.extend(generate_command_example(cmd, cmd_example))

      return section


  args = demisto.args()
  yml_data = get_yaml_obj(args['entryID'])
  command_examples = get_command_examples(args.get('commands'))

  docs = []
  docs.extend(generate_section('Overview', args.get('overview')))
  docs.append('This integration was integrated and tested with version xx of {}'.format(yml_data['name']))
  # Playbooks
  docs.extend(generate_section('{} Playbook'.format(yml_data['name']), None))
  # Use-cases
  docs.extend(generate_section('Use Cases', args.get('useCases')))
  # Setup integration to work with Demisto
  docs.extend(generate_section('Configure {} on Demisto'.format(yml_data['name']), args.get('setupOnIntegration')))
  # Setup integration on Demisto
  docs.extend(generate_setup_section(yml_data))
  # Fetched incidents data
  docs.extend(generate_section('Fetched Incidents Data', args.get('fetchedData')))
  # Commands
  docs.extend(generate_commands_section(yml_data, command_examples))
  # Additional info
  docs.extend(generate_section('Additional Information', args.get('addInfo')))
  # Known limitations
  docs.extend(generate_section('Known Limitations', args.get('limit')))
  # Troubleshooting
  docs.extend(generate_section('Troubleshooting', args.get('troubleshooting')))
  # Possible Errors

  if demisto.args()['withErrors'] == 'True':
      docs.extend([
          ''
          '## Possible Errors (DO NOT PUBLISH ON ZENDESK):',
      ])
      docs.append(addErrorLines(yml_data['script']['script'], yml_data['script']['type']))

  filename = '{}-documantation_new.txt'.format(yml_data['name'])
  demisto.results(fileResult(filename, '\n'.join(docs), file_type=entryTypes['entryInfoFile']))
type: python
tags: []
comment: Automates integration documentation
enabled: true
args:
- name: entryID
  required: true
  description: War-room entry ID of sample file
- name: overview
  description: Documentation overview
- name: setupOnIntegration
  description: Setting to work with Demisto instructions. Number the steps by 'x.'
    (i.e. '1.')
- name: useCases
  description: Top use-cases. Number the steps by 'x.' (i.e. '1.')
- name: troubleshooting
  description: Integration troubleshooting
- name: fetchedData
  description: Fetched incidents data. Number the steps by 'x.' (i.e. '1.')
- name: addInfo
  description: Additional information. Number the steps by 'x.' (i.e. '1.')
- name: limit
  description: Known limitations. Number the steps by 'x.' (i.e. '1.')
- name: withErrors
  auto: PREDEFINED
  predefined:
  - "True"
  - "False"
  description: Flag for creating documentation with errors
  defaultValue: "True"
- name: commands
  description: Entry ID for file containing command examples. Each Command should
    be in a separate line.
scripttarget: 0
runonce: false
releaseNotes: added auto-generated examples
tests:
  - No test - Test not needed